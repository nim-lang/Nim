<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="https://www.w3.org/1999/xhtml" xml:lang="en" lang="en" data-theme="auto">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Nim Tutorial (Part I)</title>

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- CSS -->
<link rel="stylesheet" type="text/css" href="nimdoc.out.css?v=2.2.1">

<!-- JS -->
<script type="text/javascript" src="dochack.js?v=2.2.1"></script>
</head>
<body>
  <div class="document" id="documentId">
    <div class="container">
      <h1 class="title">Nim Tutorial (Part I)</h1>
      <div class="row">
  <div class="three columns">
    <div class="theme-select-wrapper">
      <label for="theme-select">Theme:&nbsp;</label>
      <select id="theme-select" onchange="setTheme(this.value)">
        <option value="auto">ðŸŒ— Match OS</option>
        <option value="dark">ðŸŒ‘ Dark</option>
        <option value="light">ðŸŒ• Light</option>
      </select>
    </div>
    <div id="global-links">
      <ul class="simple-boot">
        <li><a href="manual.html">Manual</a></li>
        <li><a href="lib.html">Standard library</a></li>
        <li> <a id="indexLink" href="theindex.html">Index</a></li>
        <li><a href="compiler/theindex.html">Compiler docs</a></li>
        <li><a href="https://nim-lang.github.io/fusion/theindex.html">Fusion docs</a></li>
        <li><a href="https://nim-lang.github.io/Nim/">devel</a>, <a href="https://nim-lang.org/documentation.html">stable</a></li>
      </ul>
    </div>
    <div id="searchInputDiv">
      Search: <input type="search" id="searchInput"
        oninput="search()" />
    </div>
    <div class="search-groupby">
  Group by:
  <select onchange="groupBy(this.value)">
    <option value="section">Section</option>
    <option value="type">Type</option>
  </select>
</div>

    <ul class="simple simple-toc" id="toc-list">
  <li><a class="reference" id="introduction_toc" href="#introduction">Introduction</a></li>
<li><a class="reference" id="the-first-program_toc" href="#the-first-program">The first program</a></li>
<li><a class="reference" id="lexical-elements_toc" href="#lexical-elements">Lexical elements</a></li>
<ul class="simple"><li><a class="reference" id="lexical-elements-string-and-character-literals_toc" href="#lexical-elements-string-and-character-literals">String and character literals</a></li>
<li><a class="reference" id="lexical-elements-comments_toc" href="#lexical-elements-comments">Comments</a></li>
<li><a class="reference" id="lexical-elements-numbers_toc" href="#lexical-elements-numbers">Numbers</a></li>
</ul><li><a class="reference" id="the-var-statement_toc" href="#the-var-statement">The var statement</a></li>
<li><a class="reference" id="constants_toc" href="#constants">Constants</a></li>
<li><a class="reference" id="the-let-statement_toc" href="#the-let-statement">The let statement</a></li>
<li><a class="reference" id="the-assignment-statement_toc" href="#the-assignment-statement">The assignment statement</a></li>
<li><a class="reference" id="control-flow-statements_toc" href="#control-flow-statements">Control flow statements</a></li>
<ul class="simple"><li><a class="reference" id="control-flow-statements-if-statement_toc" href="#control-flow-statements-if-statement">If statement</a></li>
<li><a class="reference" id="control-flow-statements-case-statement_toc" href="#control-flow-statements-case-statement">Case statement</a></li>
<li><a class="reference" id="control-flow-statements-while-statement_toc" href="#control-flow-statements-while-statement">While statement</a></li>
<li><a class="reference" id="control-flow-statements-for-statement_toc" href="#control-flow-statements-for-statement">For statement</a></li>
<li><a class="reference" id="control-flow-statements-scopes-and-the-block-statement_toc" href="#control-flow-statements-scopes-and-the-block-statement">Scopes and the block statement</a></li>
<li><a class="reference" id="control-flow-statements-break-statement_toc" href="#control-flow-statements-break-statement">Break statement</a></li>
<li><a class="reference" id="control-flow-statements-continue-statement_toc" href="#control-flow-statements-continue-statement">Continue statement</a></li>
<li><a class="reference" id="control-flow-statements-when-statement_toc" href="#control-flow-statements-when-statement">When statement</a></li>
</ul><li><a class="reference" id="statements-and-indentation_toc" href="#statements-and-indentation">Statements and indentation</a></li>
<li><a class="reference" id="procedures_toc" href="#procedures">Procedures</a></li>
<ul class="simple"><li><a class="reference" id="procedures-result-variable_toc" href="#procedures-result-variable">Result variable</a></li>
<li><a class="reference" id="procedures-parameters_toc" href="#procedures-parameters">Parameters</a></li>
<li><a class="reference" id="procedures-discard-statement_toc" href="#procedures-discard-statement">Discard statement</a></li>
<li><a class="reference" id="procedures-named-arguments_toc" href="#procedures-named-arguments">Named arguments</a></li>
<li><a class="reference" id="procedures-default-values_toc" href="#procedures-default-values">Default values</a></li>
<li><a class="reference" id="procedures-overloaded-procedures_toc" href="#procedures-overloaded-procedures">Overloaded procedures</a></li>
<li><a class="reference" id="procedures-operators_toc" href="#procedures-operators">Operators</a></li>
<li><a class="reference" id="procedures-forward-declarations_toc" href="#procedures-forward-declarations">Forward declarations</a></li>
<li><a class="reference" id="procedures-funcs-and-methods_toc" href="#procedures-funcs-and-methods">Funcs and methods</a></li>
</ul><li><a class="reference" id="iterators_toc" href="#iterators">Iterators</a></li>
<li><a class="reference" id="basic-types_toc" href="#basic-types">Basic types</a></li>
<ul class="simple"><li><a class="reference" id="basic-types-booleans_toc" href="#basic-types-booleans">Booleans</a></li>
<li><a class="reference" id="basic-types-characters_toc" href="#basic-types-characters">Characters</a></li>
<li><a class="reference" id="basic-types-strings_toc" href="#basic-types-strings">Strings</a></li>
<li><a class="reference" id="basic-types-integers_toc" href="#basic-types-integers">Integers</a></li>
<li><a class="reference" id="basic-types-floats_toc" href="#basic-types-floats">Floats</a></li>
<li><a class="reference" id="basic-types-type-conversion_toc" href="#basic-types-type-conversion">Type Conversion</a></li>
</ul><li><a class="reference" id="internal-type-representation_toc" href="#internal-type-representation">Internal type representation</a></li>
<li><a class="reference" id="advanced-types_toc" href="#advanced-types">Advanced types</a></li>
<ul class="simple"><li><a class="reference" id="advanced-types-enumerations_toc" href="#advanced-types-enumerations">Enumerations</a></li>
<li><a class="reference" id="advanced-types-ordinal-types_toc" href="#advanced-types-ordinal-types">Ordinal types</a></li>
<li><a class="reference" id="advanced-types-subranges_toc" href="#advanced-types-subranges">Subranges</a></li>
<li><a class="reference" id="advanced-types-sets_toc" href="#advanced-types-sets">Sets</a></li>
<ul class="simple"><li><a class="reference" id="sets-bit-fields_toc" href="#sets-bit-fields">Bit fields</a></li>
</ul><li><a class="reference" id="advanced-types-arrays_toc" href="#advanced-types-arrays">Arrays</a></li>
<li><a class="reference" id="advanced-types-sequences_toc" href="#advanced-types-sequences">Sequences</a></li>
<li><a class="reference" id="advanced-types-open-arrays_toc" href="#advanced-types-open-arrays">Open arrays</a></li>
<li><a class="reference" id="advanced-types-varargs_toc" href="#advanced-types-varargs">Varargs</a></li>
<li><a class="reference" id="advanced-types-slices_toc" href="#advanced-types-slices">Slices</a></li>
<li><a class="reference" id="advanced-types-objects_toc" href="#advanced-types-objects">Objects</a></li>
<li><a class="reference" id="advanced-types-tuples_toc" href="#advanced-types-tuples">Tuples</a></li>
<li><a class="reference" id="advanced-types-reference-and-pointer-types_toc" href="#advanced-types-reference-and-pointer-types">Reference and pointer types</a></li>
<li><a class="reference" id="advanced-types-procedural-type_toc" href="#advanced-types-procedural-type">Procedural type</a></li>
<li><a class="reference" id="advanced-types-distinct-type_toc" href="#advanced-types-distinct-type">Distinct type</a></li>
</ul><li><a class="reference" id="modules_toc" href="#modules">Modules</a></li>
<ul class="simple"><li><a class="reference" id="modules-excluding-symbols_toc" href="#modules-excluding-symbols">Excluding symbols</a></li>
<li><a class="reference" id="modules-from-statement_toc" href="#modules-from-statement">From statement</a></li>
<li><a class="reference" id="modules-include-statement_toc" href="#modules-include-statement">Include statement</a></li>
</ul><li><a class="reference" id="part-2_toc" href="#part-2">Part 2</a></li>

</ul>

  </div>
  <div class="nine columns" id="content">
    <a href="https://github.com/nim-lang/Nim/tree/devel/doc/tut1.md#L1" class="link-seesrc" target="_blank">Source</a>&nbsp;&nbsp;
<a href="https://github.com/nim-lang/Nim/edit/devel/doc/tut1.md#L1" class="link-seesrc" target="_blank" >Edit</a>&nbsp;&nbsp;

    <div id="tocRoot"></div>
    
    <p class="module-desc"><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">Author:</th><td>Andreas Rumpf</td></tr>
<tr><th class="docinfo-name">Version:</th><td>2.2.1</td></tr>
</tbody></table>
<h1><a class="toc-backref" id="introduction" href="#introduction">Introduction</a></h1><blockquote class="markdown-quote"><p>&quot;Der Mensch ist doch ein Augentier -- SchÃ¶ne Dinge wÃ¼nsch' ich mir.&quot;</p></blockquote>
<p>This document is a tutorial for the programming language <em>Nim</em>.</p>
<p>This tutorial assumes that you are familiar with basic programming concepts like variables, types, or statements.</p>
<p>Here are several other resources for learning Nim:</p>
<ul class="simple"><li><a class="reference external" href="https://narimiran.github.io/nim-basics/">Nim Basics tutorial</a> - a gentle introduction of the concepts mentioned above</li>
<li><a class="reference external" href="https://learnxinyminutes.com/docs/nim/">Learn Nim in 5 minutes</a> - quick, five-minute introduction to Nim</li>
<li><a class="reference external" href="manual.html">The Nim manual</a> - many more examples of the advanced language features</li>
</ul>
<p>All code examples in this tutorial, as well as the ones found in the rest of Nim's documentation, follow the <a class="reference external" href="nep1.html">Nim style guide</a>.</p>

<h1><a class="toc-backref" id="the-first-program" href="#the-first-program">The first program</a></h1><p>We start the tour with a modified &quot;hello world&quot; program:</p>
<p><pre class="listing"><span class="Comment"># This is a comment</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;What's your name? &quot;</span>
<span class="Keyword">var</span> <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;Hi, &quot;</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="StringLit">&quot;!&quot;</span></pre></p>
<p>Save this code to the file &quot;greetings.nim&quot;. Now compile and run it:</p>
<p><pre class="listing"><span class="program">nim</span> <span class="option">compile</span> <span class="option">--run</span> <span class="Identifier">greetings.nim</span></pre></p>
<p>With the <tt class="docutils literal"><span class="pre">--run</span></tt> <a class="reference external" href="nimc.html#compiler-usage-commandminusline-switches">switch</a> Nim executes the file automatically after compilation. You can give your program command-line arguments by appending them after the filename:</p>
<p><pre class="listing"><span class="program">nim</span> <span class="option">compile</span> <span class="option">--run</span> <span class="Identifier">greetings.nim</span> <span class="option">arg1</span> <span class="option">arg2</span></pre></p>
<p>Commonly used commands and switches have abbreviations, so you can also use:</p>
<p><pre class="listing"><span class="program">nim</span> <span class="option">c</span> <span class="option">-r</span> <span class="Identifier">greetings.nim</span></pre></p>
<p>This is a <strong>debug version</strong>. To compile a release version use:</p>
<p><pre class="listing"><span class="program">nim</span> <span class="option">c</span> <span class="option">-d:release</span> <span class="Identifier">greetings.nim</span></pre></p>
<p>By default, the Nim compiler generates a large number of runtime checks aiming for your debugging pleasure. With <tt class="docutils literal"><span class="pre">-d:release</span></tt> some checks are <a class="reference external" href=" nimc.html#compiler-usage-compileminustime-symbols">turned off and optimizations are turned on</a>.</p>
<p>For benchmarking or production code, use the <tt class="docutils literal"><span class="pre">-d:release</span></tt> switch. For comparing the performance with unsafe languages like C, use the <tt class="docutils literal"><span class="pre">-d:danger</span></tt> switch in order to get meaningful, comparable results. Otherwise, Nim might be handicapped by checks that are <strong>not even available</strong> for C.</p>
<p>Though it should be pretty obvious what the program does, I will explain the syntax: statements which are not indented are executed when the program starts. Indentation is Nim's way of grouping statements. Indentation is done with spaces only, tabulators are not allowed.</p>
<p>String literals are enclosed in double-quotes. The <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> statement declares a new variable named <tt class="docutils literal"><span class="pre"><span class="Identifier">name</span></span></tt> of type <tt class="docutils literal"><span class="pre"><span class="Identifier">string</span></span></tt> with the value that is returned by the <a class="reference external" href="syncio.html#readLine,File">readLine</a> procedure. Since the compiler knows that <a class="reference external" href="syncio.html#readLine,File">readLine</a> returns a string, you can leave out the type in the declaration (this is called <span id="local-type-inference_1">local type inference</span>). So this will work too:</p>
<p><pre class="listing"><span class="Keyword">var</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span></pre></p>
<p>Note that this is basically the only form of type inference that exists in Nim: it is a good compromise between brevity and readability.</p>
<p>The &quot;hello world&quot; program contains several identifiers that are already known to the compiler: <tt class="docutils literal"><span class="pre"><span class="Identifier">echo</span></span></tt>, <a class="reference external" href="syncio.html#readLine,File">readLine</a>, etc. These built-ins are declared in the <a class="reference external" href="system.html">system</a> module which is implicitly imported by any other module.</p>

<h1><a class="toc-backref" id="lexical-elements" href="#lexical-elements">Lexical elements</a></h1><p>Let us look at Nim's lexical elements in more detail: like other programming languages Nim consists of (string) literals, identifiers, keywords, comments, operators, and other punctuation marks.</p>

<h2><a class="toc-backref" id="lexical-elements-string-and-character-literals" href="#lexical-elements-string-and-character-literals">String and character literals</a></h2><p>String literals are enclosed in double-quotes; character literals in single quotes. Special characters are escaped with <tt class="docutils literal"><span class="pre">\</span></tt>: <tt class="docutils literal"><span class="pre">\n</span></tt> means newline, <tt class="docutils literal"><span class="pre">\t</span></tt> means tabulator, etc. There are also <em>raw</em> string literals:</p>
<p><pre class="listing"><span class="RawData">r&quot;C:\program files\nim&quot;</span></pre></p>
<p>In raw literals, the backslash is not an escape character.</p>
<p>The third and last way to write string literals is <em>long-string literals</em>. They are written with three quotes: <tt class="docutils literal"><span class="pre"><span class="LongStringLit">&quot;&quot;&quot; ... &quot;&quot;&quot;</span></span></tt>; they can span over multiple lines and the <tt class="docutils literal"><span class="pre">\</span></tt> is not an escape character either. They are very useful for embedding HTML code templates for example.</p>

<h2><a class="toc-backref" id="lexical-elements-comments" href="#lexical-elements-comments">Comments</a></h2><p>Comments start anywhere outside a string or character literal with the hash character <tt class="docutils literal"><span class="pre"><span class="Comment">#</span></span></tt>. Documentation comments start with <tt class="docutils literal"><span class="pre"><span class="Comment">##</span></span></tt>:</p>
<p><pre class="listing"><span class="Comment"># A comment.</span>

<span class="Keyword">var</span> <span class="Identifier">myVariable</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment">## a documentation comment</span></pre></p>
<p>Documentation comments are tokens; they are only allowed at certain places in the input file as they belong to the syntax tree! This feature enables simpler documentation generators.</p>
<p>Multiline comments are started with <tt class="docutils literal"><span class="pre"><span class="LongComment">#[</span></span></tt> and terminated with <tt class="docutils literal"><span class="pre"><span class="Punctuation">]</span><span class="Comment">#</span></span></tt>.  Multiline comments can also be nested.</p>
<p><pre class="listing"><span class="LongComment">#[
You can have any Nim code text commented
out inside this with no indentation restrictions.
      yes(&quot;May I ask a pointless question?&quot;)
  #[
     Note: these can be nested!!
  ]#
]#</span></pre></p>

<h2><a class="toc-backref" id="lexical-elements-numbers" href="#lexical-elements-numbers">Numbers</a></h2><p>Numerical literals are written as in most other languages. As a special twist, underscores are allowed for better readability: <tt class="docutils literal"><span class="pre"><span class="DecNumber">1_000_000</span></span></tt> (one million). A number that contains a dot (or 'e' or 'E') is a floating-point literal: <tt class="docutils literal"><span class="pre"><span class="FloatNumber">1.0e9</span></span></tt> (one billion). Hexadecimal literals are prefixed with <tt class="docutils literal"><span class="pre"><span class="HexNumber">0x</span></span></tt>, binary literals with <tt class="docutils literal"><span class="pre"><span class="BinNumber">0b</span></span></tt> and octal literals with <tt class="docutils literal"><span class="pre"><span class="OctNumber">0o</span></span></tt>. A leading zero alone does not produce an octal.</p>

<h1><a class="toc-backref" id="the-var-statement" href="#the-var-statement">The var statement</a></h1><p>The var statement declares a new local or global variable:</p>
<p><pre class="listing"><span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment"># declares x and y to have the type `int`</span></pre></p>
<p>Indentation can be used after the <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> keyword to list a whole section of variables:</p>
<p><pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Comment"># a comment can occur here too</span>
  <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">string</span></pre></p>

<h1><a class="toc-backref" id="constants" href="#constants">Constants</a></h1><p>Constants are symbols which are bound to a value. The constant's value cannot change. The compiler must be able to evaluate the expression in a constant declaration at compile time:</p>
<p><pre class="listing"><span class="Keyword">const</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span> <span class="Comment"># the constant x contains the string &quot;abc&quot;</span></pre></p>
<p>Indentation can be used after the <tt class="docutils literal"><span class="pre"><span class="Keyword">const</span></span></tt> keyword to list a whole section of constants:</p>
<p><pre class="listing"><span class="Keyword">const</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
  <span class="Comment"># a comment can occur here too</span>
  <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">2</span>
  <span class="Identifier">z</span> <span class="Operator">=</span> <span class="Identifier">y</span> <span class="Operator">+</span> <span class="DecNumber">5</span> <span class="Comment"># computations are possible</span></pre></p>

<h1><a class="toc-backref" id="the-let-statement" href="#the-let-statement">The let statement</a></h1><p>The <tt class="docutils literal"><span class="pre"><span class="Keyword">let</span></span></tt> statement works like the <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> statement but the declared symbols are <em>single assignment</em> variables: After the initialization their value cannot change:</p>
<p><pre class="listing"><span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span> <span class="Comment"># introduces a new variable `x` and binds a value to it</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;xyz&quot;</span>     <span class="Comment"># Illegal: assignment to `x`</span></pre></p>
<p>The difference between <tt class="docutils literal"><span class="pre"><span class="Keyword">let</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Keyword">const</span></span></tt> is: <tt class="docutils literal"><span class="pre"><span class="Keyword">let</span></span></tt> introduces a variable that can not be re-assigned, <tt class="docutils literal"><span class="pre"><span class="Keyword">const</span></span></tt> means &quot;enforce compile time evaluation and put it into a data section&quot;:</p>
<p><pre class="listing"><span class="Keyword">const</span> <span class="Identifier">input</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span> <span class="Comment"># Error: constant expression expected</span></pre></p>
<p><pre class="listing"><span class="Keyword">let</span> <span class="Identifier">input</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>   <span class="Comment"># works</span></pre></p>

<h1><a class="toc-backref" id="the-assignment-statement" href="#the-assignment-statement">The assignment statement</a></h1><p>The assignment statement assigns a new value to a variable or more generally to a storage location:</p>
<p><pre class="listing"><span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span> <span class="Comment"># introduces a new variable `x` and assigns a value to it</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;xyz&quot;</span>     <span class="Comment"># assigns a new value to `x`</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Operator">=</span></span></tt> is the <em>assignment operator</em>. The assignment operator can be overloaded. You can declare multiple variables with a single assignment statement and all the variables will have the same value:</p>
<p><pre class="listing"><span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">3</span>  <span class="Comment"># assigns 3 to the variables `x` and `y`</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;x &quot;</span><span class="Punctuation">,</span> <span class="Identifier">x</span>  <span class="Comment"># outputs &quot;x 3&quot;</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;y &quot;</span><span class="Punctuation">,</span> <span class="Identifier">y</span>  <span class="Comment"># outputs &quot;y 3&quot;</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">42</span>        <span class="Comment"># changes `x` to 42 without changing `y`</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;x &quot;</span><span class="Punctuation">,</span> <span class="Identifier">x</span>  <span class="Comment"># outputs &quot;x 42&quot;</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;y &quot;</span><span class="Punctuation">,</span> <span class="Identifier">y</span>  <span class="Comment"># outputs &quot;y 3&quot;</span></pre></p>

<h1><a class="toc-backref" id="control-flow-statements" href="#control-flow-statements">Control flow statements</a></h1><p>The greetings program consists of 3 statements that are executed sequentially. Only the most primitive programs can get away with that: branching and looping are needed too.</p>

<h2><a class="toc-backref" id="control-flow-statements-if-statement" href="#control-flow-statements-if-statement">If statement</a></h2><p>The if statement is one way to branch the control flow:</p>
<p><pre class="listing"><span class="Keyword">let</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">if</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Poor soul, you lost your name?&quot;</span>
<span class="Keyword">elif</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;name&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Very funny, your name is name.&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Hi, &quot;</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="StringLit">&quot;!&quot;</span></pre></p>
<p>There can be zero or more <tt class="docutils literal"><span class="pre"><span class="Keyword">elif</span></span></tt> parts, and the <tt class="docutils literal"><span class="pre"><span class="Keyword">else</span></span></tt> part is optional. The keyword <tt class="docutils literal"><span class="pre"><span class="Keyword">elif</span></span></tt> is short for <tt class="docutils literal"><span class="pre"><span class="Keyword">else</span> <span class="Keyword">if</span></span></tt>, and is useful to avoid excessive indentation. (The <tt class="docutils literal"><span class="pre"><span class="StringLit">&quot;&quot;</span></span></tt> is the empty string. It contains no characters.)</p>

<h2><a class="toc-backref" id="control-flow-statements-case-statement" href="#control-flow-statements-case-statement">Case statement</a></h2><p>Another way to branch is provided by the case statement. A case statement allows for multiple branches:</p>
<p><pre class="listing"><span class="Keyword">let</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">case</span> <span class="Identifier">name</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Poor soul, you lost your name?&quot;</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;name&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Very funny, your name is name.&quot;</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;Dave&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Frank&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Cool name!&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Hi, &quot;</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="StringLit">&quot;!&quot;</span></pre></p>
<p>As it can be seen, for an <tt class="docutils literal"><span class="pre"><span class="Keyword">of</span></span></tt> branch a comma-separated list of values is also allowed.</p>
<p>The case statement can deal with integers, other ordinal types, and strings. (What an ordinal type is will be explained soon.) For integers or other ordinal types value ranges are also possible:</p>
<p><pre class="listing"><span class="Comment"># this statement will be explained later:</span>
<span class="Keyword">from</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">strutils</span> <span class="Keyword">import</span> <span class="Identifier">parseInt</span>

<span class="Identifier">echo</span> <span class="StringLit">&quot;A number please: &quot;</span>
<span class="Keyword">let</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Keyword">case</span> <span class="Identifier">n</span>
<span class="Keyword">of</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="FloatNumber">4.</span><span class="Operator">.</span><span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;The number is in the set: {0, 1, 2, 4, 5, 6, 7}&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;The number is 3 or 8&quot;</span></pre></p>
<p>However, the above code <strong>does not compile</strong>: the reason is that you have to cover every value that <tt class="docutils literal"><span class="pre"><span class="Identifier">n</span></span></tt> may contain, but the code only handles the values <tt class="docutils literal"><span class="pre"><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">8</span></span></tt>. Since it is not very practical to list every other possible integer (though it is possible thanks to the range notation), we fix this by telling the compiler that for every other value nothing should be done:</p>
<p><pre class="listing"><span class="Operator">...</span>
<span class="Keyword">case</span> <span class="Identifier">n</span>
<span class="Keyword">of</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="FloatNumber">4.</span><span class="Operator">.</span><span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;The number is in the set: {0, 1, 2, 4, 5, 6, 7}&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;The number is 3 or 8&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Keyword">discard</span></pre></p>
<p>The empty <a class="reference internal" href="#procedures-discard-statement">discard statement</a> is a <em>do nothing</em> statement. The compiler knows that a case statement with an else part cannot fail and thus the error disappears. Note that it is impossible to cover all possible string values: that is why string cases always need an <tt class="docutils literal"><span class="pre"><span class="Keyword">else</span></span></tt> branch.</p>
<p>In general, the case statement is used for subrange types or enumerations where it is of great help that the compiler checks that you covered any possible value.</p>

<h2><a class="toc-backref" id="control-flow-statements-while-statement" href="#control-flow-statements-while-statement">While statement</a></h2><p>The while statement is a simple looping construct:</p>
<p><pre class="listing"><span class="Identifier">echo</span> <span class="StringLit">&quot;What's your name? &quot;</span>
<span class="Keyword">var</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">while</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Please tell me your name: &quot;</span>
  <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span> <span class="Comment"># no `var`, because we do not declare a new variable here</span></pre></p>
<p>The example uses a while loop to keep asking the users for their name, as long as the user types in nothing (only presses RETURN).</p>

<h2><a class="toc-backref" id="control-flow-statements-for-statement" href="#control-flow-statements-for-statement">For statement</a></h2><p>The <tt class="docutils literal"><span class="pre"><span class="Keyword">for</span></span></tt> statement is a construct to loop over any element an <em>iterator</em> provides. The example uses the built-in <a class="reference external" href=" system.html#countup.i,T,T,Positive">countup</a> iterator:</p>
<p><pre class="listing"><span class="Identifier">echo</span> <span class="StringLit">&quot;Counting to ten: &quot;</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">countup</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">10</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span>
<span class="Comment"># --&gt; Outputs 1 2 3 4 5 6 7 8 9 10 on different lines</span></pre></p>
<p>The variable <tt class="docutils literal"><span class="pre"><span class="Identifier">i</span></span></tt> is implicitly declared by the <tt class="docutils literal"><span class="pre"><span class="Keyword">for</span></span></tt> loop and has the type <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt>, because that is what <a class="reference external" href=" system.html#countup.i,T,T,Positive">countup</a> returns. <tt class="docutils literal"><span class="pre"><span class="Identifier">i</span></span></tt> runs through the values 1, 2, .., 10. Each value is <tt class="docutils literal"><span class="pre"><span class="Identifier">echo</span></span></tt>-ed. This code does the same:</p>
<p><pre class="listing"><span class="Identifier">echo</span> <span class="StringLit">&quot;Counting to 10: &quot;</span>
<span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
<span class="Keyword">while</span> <span class="Identifier">i</span> <span class="Operator">&lt;=</span> <span class="DecNumber">10</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span>
  <span class="Identifier">inc</span> <span class="Identifier">i</span> <span class="Comment"># increment i by 1</span>
<span class="Comment"># --&gt; Outputs 1 2 3 4 5 6 7 8 9 10 on different lines</span></pre></p>
<p>Since counting up occurs so often in programs, Nim also has a <a class="reference external" href=" system.html#...i,T,T">..</a> iterator that does the same:</p>
<p><pre class="listing"><span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">1</span> <span class="Operator">..</span> <span class="DecNumber">10</span><span class="Punctuation">:</span>
  <span class="Operator">...</span></pre></p>
<p>Counting down can be achieved as easily (but is less often needed):</p>
<p><pre class="listing"><span class="Identifier">echo</span> <span class="StringLit">&quot;Counting down from 10 to 1: &quot;</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">countdown</span><span class="Punctuation">(</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span>
<span class="Comment"># --&gt; Outputs 10 9 8 7 6 5 4 3 2 1 on different lines</span></pre></p>
<p>Zero-indexed counting has two shortcuts <tt class="docutils literal"><span class="pre"><span class="Operator">..&lt;</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Operator">..</span> <span class="Operator">^</span><span class="DecNumber">1</span></span></tt> (<a class="reference external" href="system.html#^.t%2Cint">backward index operator</a>) to simplify counting to one less than the higher index:</p>
<p><pre class="listing"><span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">0</span> <span class="Operator">..&lt;</span> <span class="DecNumber">10</span><span class="Punctuation">:</span>
  <span class="Operator">...</span>  <span class="Comment"># the same as 0 .. 9</span></pre></p>
<p>or</p>
<p><pre class="listing"><span class="Keyword">var</span> <span class="Identifier">s</span> <span class="Operator">=</span> <span class="StringLit">&quot;some string&quot;</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">0</span> <span class="Operator">..&lt;</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">:</span>
  <span class="Operator">...</span></pre></p>
<p>or</p>
<p><pre class="listing"><span class="Keyword">var</span> <span class="Identifier">s</span> <span class="Operator">=</span> <span class="StringLit">&quot;some string&quot;</span>
<span class="Keyword">for</span> <span class="Identifier">idx</span><span class="Punctuation">,</span> <span class="Identifier">c</span> <span class="Keyword">in</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span> <span class="Operator">..</span> <span class="Operator">^</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">:</span>
  <span class="Operator">...</span> <span class="Comment"># ^1 is the last element, ^2 would be one before it, and so on</span></pre></p>
<p>Other useful iterators for collections (like arrays and sequences) are</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre"><span class="Identifier">items</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">mitems</span></span></tt>, which provides immutable and mutable elements respectively, and</li>
<li><p><tt class="docutils literal"><span class="pre"><span class="Identifier">pairs</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">mpairs</span></span></tt> which provides the element and an index number (immutable and mutable respectively)</p>
<p><pre class="listing"><span class="Keyword">for</span> <span class="Identifier">index</span><span class="Punctuation">,</span> <span class="Identifier">item</span> <span class="Keyword">in</span> <span class="Punctuation">[</span><span class="StringLit">&quot;a&quot;</span><span class="Punctuation">,</span><span class="StringLit">&quot;b&quot;</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">pairs</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">item</span><span class="Punctuation">,</span> <span class="StringLit">&quot; at index &quot;</span><span class="Punctuation">,</span> <span class="Identifier">index</span>
<span class="Comment"># =&gt; a at index 0</span>
<span class="Comment"># =&gt; b at index 1</span></pre></p>
</li>
</ul>

<h2><a class="toc-backref" id="control-flow-statements-scopes-and-the-block-statement" href="#control-flow-statements-scopes-and-the-block-statement">Scopes and the block statement</a></h2><p>Control flow statements have a feature not covered yet: they open a new scope. This means that in the following example, <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> is not accessible outside the loop:</p>
<p><pre class="listing"><span class="Keyword">while</span> <span class="Identifier">false</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;hi&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span> <span class="Comment"># does not work</span></pre></p>
<p>A while (for) statement introduces an implicit block. Identifiers are only visible within the block they have been declared. The <tt class="docutils literal"><span class="pre"><span class="Keyword">block</span></span></tt> statement can be used to open a new block explicitly:</p>
<p><pre class="listing"><span class="Keyword">block</span> <span class="Identifier">myblock</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;hi&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span> <span class="Comment"># does not work either</span></pre></p>
<p>The block's <em>label</em> (<tt class="docutils literal"><span class="pre"><span class="Identifier">myblock</span></span></tt> in the example) is optional.</p>

<h2><a class="toc-backref" id="control-flow-statements-break-statement" href="#control-flow-statements-break-statement">Break statement</a></h2><p>A block can be left prematurely with a <tt class="docutils literal"><span class="pre"><span class="Keyword">break</span></span></tt> statement. The break statement can leave a <tt class="docutils literal"><span class="pre"><span class="Keyword">while</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">for</span></span></tt>, or a <tt class="docutils literal"><span class="pre"><span class="Keyword">block</span></span></tt> statement. It leaves the innermost construct, unless a label of a block is given:</p>
<p><pre class="listing"><span class="Keyword">block</span> <span class="Identifier">myblock</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;entering block&quot;</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;looping&quot;</span>
    <span class="Keyword">break</span> <span class="Comment"># leaves the loop, but not the block</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;still in block&quot;</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;outside the block&quot;</span>

<span class="Keyword">block</span> <span class="Identifier">myblock2</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;entering block&quot;</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;looping&quot;</span>
    <span class="Keyword">break</span> <span class="Identifier">myblock2</span> <span class="Comment"># leaves the block (and the loop)</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;still in block&quot;</span> <span class="Comment"># it won't be printed</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;outside the block&quot;</span></pre></p>

<h2><a class="toc-backref" id="control-flow-statements-continue-statement" href="#control-flow-statements-continue-statement">Continue statement</a></h2><p>Like in many other programming languages, a <tt class="docutils literal"><span class="pre"><span class="Keyword">continue</span></span></tt> statement starts the next iteration immediately:</p>
<p><pre class="listing"><span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">1</span> <span class="Operator">..</span> <span class="DecNumber">5</span><span class="Punctuation">:</span>
  <span class="Keyword">if</span> <span class="Identifier">i</span> <span class="Operator">&lt;=</span> <span class="DecNumber">3</span><span class="Punctuation">:</span> <span class="Keyword">continue</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span> <span class="Comment"># will only print 4 and 5</span></pre></p>

<h2><a class="toc-backref" id="control-flow-statements-when-statement" href="#control-flow-statements-when-statement">When statement</a></h2><p>Example:</p>
<p><pre class="listing"><span class="Keyword">when</span> <span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">hostOS</span> <span class="Operator">==</span> <span class="StringLit">&quot;windows&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;running on Windows!&quot;</span>
<span class="Keyword">elif</span> <span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">hostOS</span> <span class="Operator">==</span> <span class="StringLit">&quot;linux&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;running on Linux!&quot;</span>
<span class="Keyword">elif</span> <span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">hostOS</span> <span class="Operator">==</span> <span class="StringLit">&quot;macosx&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;running on Mac OS X!&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;unknown operating system&quot;</span></pre></p>
<p>The <tt class="docutils literal"><span class="pre"><span class="Keyword">when</span></span></tt> statement is almost identical to the <tt class="docutils literal"><span class="pre"><span class="Keyword">if</span></span></tt> statement, but with these differences:</p>
<ul class="simple"><li>Each condition must be a constant expression since it is evaluated by the compiler.</li>
<li>The statements within a branch do not open a new scope.</li>
<li>The compiler checks the semantics and produces code <em>only</em> for the statements that belong to the first condition that evaluates to <tt class="docutils literal"><span class="pre"><span class="Identifier">true</span></span></tt>.</li>
</ul>
<p>The <tt class="docutils literal"><span class="pre"><span class="Keyword">when</span></span></tt> statement is useful for writing platform-specific code, similar to the <tt class="docutils literal"><span class="pre"><span class="Preprocessor">#ifdef</span></span></tt> construct in the C programming language.</p>

<h1><a class="toc-backref" id="statements-and-indentation" href="#statements-and-indentation">Statements and indentation</a></h1><p>Now that we covered the basic control flow statements, let's return to Nim indentation rules.</p>
<p>In Nim, there is a distinction between <em>simple statements</em> and <em>complex statements</em>. <em>Simple statements</em> cannot contain other statements: Assignment, procedure calls, or the <tt class="docutils literal"><span class="pre"><span class="Keyword">return</span></span></tt> statement are all simple statements. <em>Complex statements</em> like <tt class="docutils literal"><span class="pre"><span class="Keyword">if</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">when</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">for</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">while</span></span></tt> can contain other statements. To avoid ambiguities, complex statements must always be indented, but single simple statements do not:</p>
<p><pre class="listing"><span class="Comment"># no indentation needed for single-assignment statement:</span>
<span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">false</span>

<span class="Comment"># indentation needed for nested if statement:</span>
<span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">:</span>
  <span class="Keyword">if</span> <span class="Identifier">y</span><span class="Punctuation">:</span>
    <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">false</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">true</span>

<span class="Comment"># indentation needed, because two statements follow the condition:</span>
<span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">:</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">false</span>
  <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">false</span></pre></p>
<p><em>Expressions</em> are parts of a statement that usually result in a value. The condition in an if statement is an example of an expression. Expressions can contain indentation at certain places for better readability:</p>
<p><pre class="listing"><span class="Keyword">if</span> <span class="Identifier">thisIsaLongCondition</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
    <span class="Identifier">thisIsAnotherLongCondition</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span>
       <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">true</span></pre></p>
<p>As a rule of thumb, indentation within expressions is allowed after operators, an open parenthesis and after commas.</p>
<p>With parenthesis and semicolons <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Punctuation">;</span><span class="Punctuation">)</span></span></tt> you can use statements where only an expression is allowed:</p>
<p><pre class="listing"><span class="Comment"># computes fac(4) at compile time:</span>
<span class="Keyword">const</span> <span class="Identifier">fac4</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">1</span><span class="Punctuation">;</span> <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">1.</span><span class="Operator">.</span><span class="DecNumber">4</span><span class="Punctuation">:</span> <span class="Identifier">x</span> <span class="Operator">*=</span> <span class="Identifier">i</span><span class="Punctuation">;</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre></p>

<h1><a class="toc-backref" id="procedures" href="#procedures">Procedures</a></h1><p>To define new commands like <a class="reference external" href="system.html#echo,varargs[typed,]">echo</a> and <a class="reference external" href="syncio.html#readLine,File">readLine</a> in the examples, the concept of a <em>procedure</em> is needed. You might be used to them being called <em>methods</em> or <em>functions</em> in other languages, but Nim <a class="reference external" href="tut1.html#procedures-funcs-and-methods">differentiates these concepts</a>. In Nim, new procedures are defined with the <tt class="docutils literal"><span class="pre"><span class="Keyword">proc</span></span></tt> keyword:</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">yes</span><span class="Punctuation">(</span><span class="Identifier">question</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">question</span><span class="Punctuation">,</span> <span class="StringLit">&quot; (y/n)&quot;</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Keyword">case</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="StringLit">&quot;y&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Y&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;yes&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Yes&quot;</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
    <span class="Keyword">of</span> <span class="StringLit">&quot;n&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;N&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;no&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;No&quot;</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">false</span>
    <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;Please be clear: yes or no&quot;</span>

<span class="Keyword">if</span> <span class="Identifier">yes</span><span class="Punctuation">(</span><span class="StringLit">&quot;Should I delete all your important files?&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;I'm sorry Dave, I'm afraid I can't do that.&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;I think you know what the problem is just as well as I do.&quot;</span></pre></p>
<p>This example shows a procedure named <tt class="docutils literal"><span class="pre"><span class="Identifier">yes</span></span></tt> that asks the user a <tt class="docutils literal"><span class="pre"><span class="Identifier">question</span></span></tt> and returns true if they answered &quot;yes&quot; (or something similar) and returns false if they answered &quot;no&quot; (or something similar). A <tt class="docutils literal"><span class="pre"><span class="Keyword">return</span></span></tt> statement leaves the procedure (and therefore the while loop) immediately. The <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Identifier">question</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span></span></tt> syntax describes that the procedure expects a parameter named <tt class="docutils literal"><span class="pre"><span class="Identifier">question</span></span></tt> of type <tt class="docutils literal"><span class="pre"><span class="Identifier">string</span></span></tt> and returns a value of type <tt class="docutils literal"><span class="pre"><span class="Identifier">bool</span></span></tt>. The <tt class="docutils literal"><span class="pre"><span class="Identifier">bool</span></span></tt> type is built-in: the only valid values for <tt class="docutils literal"><span class="pre"><span class="Identifier">bool</span></span></tt> are <tt class="docutils literal"><span class="pre"><span class="Identifier">true</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">false</span></span></tt>. The conditions in if or while statements must be of type <tt class="docutils literal"><span class="pre"><span class="Identifier">bool</span></span></tt>.</p>
<p>Some terminology: in the example <tt class="docutils literal"><span class="pre"><span class="Identifier">question</span></span></tt> is called a (formal) <em>parameter</em>, <tt class="docutils literal"><span class="pre"><span class="StringLit">&quot;Should I...&quot;</span></span></tt> is called an <em>argument</em> that is passed to this parameter.</p>

<h2><a class="toc-backref" id="procedures-result-variable" href="#procedures-result-variable">Result variable</a></h2><p>A procedure that returns a value has an implicit <tt class="docutils literal"><span class="pre"><span class="Identifier">result</span></span></tt> variable declared that represents the return value. A <tt class="docutils literal"><span class="pre"><span class="Keyword">return</span></span></tt> statement with no expression is shorthand for <tt class="docutils literal"><span class="pre"><span class="Keyword">return</span> <span class="Identifier">result</span></span></tt>. The <tt class="docutils literal"><span class="pre"><span class="Identifier">result</span></span></tt> value is always returned automatically at the end of a procedure if there is no <tt class="docutils literal"><span class="pre"><span class="Keyword">return</span></span></tt> statement at the exit.</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">sumTillNegative</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">x</span><span class="Punctuation">:</span>
    <span class="Keyword">if</span> <span class="Identifier">i</span> <span class="Operator">&lt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
      <span class="Keyword">return</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">result</span> <span class="Operator">+</span> <span class="Identifier">i</span>

<span class="Identifier">echo</span> <span class="Identifier">sumTillNegative</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Comment"># echoes 0</span>
<span class="Identifier">echo</span> <span class="Identifier">sumTillNegative</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">)</span> <span class="Comment"># echoes 12</span>
<span class="Identifier">echo</span> <span class="Identifier">sumTillNegative</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span> <span class="Punctuation">,</span> <span class="Operator">-</span><span class="DecNumber">1</span> <span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">)</span> <span class="Comment"># echoes 7</span></pre></p>
<p>The <tt class="docutils literal"><span class="pre"><span class="Identifier">result</span></span></tt> variable is already implicitly declared at the start of the function, so declaring it again with 'var result', for example, would shadow it with a normal variable of the same name. The result variable is also already initialized with the type's default value. Note that referential data types will be <tt class="docutils literal"><span class="pre"><span class="Keyword">nil</span></span></tt> at the start of the procedure, and thus may require manual initialization.</p>
<p>A procedure that does not have any <tt class="docutils literal"><span class="pre"><span class="Keyword">return</span></span></tt> statement and does not use the special <tt class="docutils literal"><span class="pre"><span class="Identifier">result</span></span></tt> variable returns the value of its last expression. For example, this procedure</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">helloWorld</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="StringLit">&quot;Hello, World!&quot;</span></pre></p>
<p>returns the string &quot;Hello, World!&quot;.</p>

<h2><a class="toc-backref" id="procedures-parameters" href="#procedures-parameters">Parameters</a></h2><p>Parameters are immutable in the procedure body. By default, their value cannot be changed because this allows the compiler to implement parameter passing in the most efficient way. If a mutable variable is needed inside the procedure, it has to be declared with <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> in the procedure body. Shadowing the parameter name is possible, and actually an idiom:</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">printSeq</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">,</span> <span class="Identifier">nprinted</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">nprinted</span> <span class="Operator">=</span> <span class="Keyword">if</span> <span class="Identifier">nprinted</span> <span class="Operator">==</span> <span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">min</span><span class="Punctuation">(</span><span class="Identifier">nprinted</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">0</span> <span class="Operator">..&lt;</span> <span class="Identifier">nprinted</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></pre></p>
<p>If the procedure needs to modify the argument for the caller, a <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> parameter can be used:</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">res</span><span class="Punctuation">,</span> <span class="Identifier">remainder</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">res</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">div</span> <span class="Identifier">b</span>        <span class="Comment"># integer division</span>
  <span class="Identifier">remainder</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">mod</span> <span class="Identifier">b</span>  <span class="Comment"># integer modulo operation</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Comment"># modifies x and y</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span>
<span class="Identifier">echo</span> <span class="Identifier">y</span></pre></p>
<p>In the example, <tt class="docutils literal"><span class="pre"><span class="Identifier">res</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">remainder</span></span></tt> are <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span> <span class="Identifier">parameters</span></span></tt>. Var parameters can be modified by the procedure and the changes are visible to the caller. Note that the above example would better make use of a tuple as a return value instead of using var parameters.</p>

<h2><a class="toc-backref" id="procedures-discard-statement" href="#procedures-discard-statement">Discard statement</a></h2><p>To call a procedure that returns a value just for its side effects and ignoring its return value, a <tt class="docutils literal"><span class="pre"><span class="Keyword">discard</span></span></tt> statement <strong>must</strong> be used. Nim does not allow silently throwing away a return value:</p>
<p><pre class="listing"><span class="Keyword">discard</span> <span class="Identifier">yes</span><span class="Punctuation">(</span><span class="StringLit">&quot;May I ask a pointless question?&quot;</span><span class="Punctuation">)</span></pre></p>
<p>The return value can be ignored implicitly if the called proc/iterator has been declared with the <tt class="docutils literal"><span class="pre"><span class="Identifier">discardable</span></span></tt> pragma:</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">discardable</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">return</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>

<span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span> <span class="Comment"># now valid</span></pre></p>

<h2><a class="toc-backref" id="procedures-named-arguments" href="#procedures-named-arguments">Named arguments</a></h2><p>Often a procedure has many parameters and it is not clear in which order the parameters appear. This is especially true for procedures that construct a complex data type. Therefore, the arguments to a procedure can be named, so that it is clear which argument belongs to which parameter:</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">width</span><span class="Punctuation">,</span> <span class="Identifier">height</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">title</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">;</span>
                  <span class="Identifier">show</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Window</span> <span class="Operator">=</span>
   <span class="Operator">...</span>

<span class="Keyword">var</span> <span class="Identifier">w</span> <span class="Operator">=</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="Identifier">show</span> <span class="Operator">=</span> <span class="Identifier">true</span><span class="Punctuation">,</span> <span class="Identifier">title</span> <span class="Operator">=</span> <span class="StringLit">&quot;My Application&quot;</span><span class="Punctuation">,</span>
                     <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">height</span> <span class="Operator">=</span> <span class="DecNumber">600</span><span class="Punctuation">,</span> <span class="Identifier">width</span> <span class="Operator">=</span> <span class="DecNumber">800</span><span class="Punctuation">)</span></pre></p>
<p>Now that we use named arguments to call <tt class="docutils literal"><span class="pre"><span class="Identifier">createWindow</span></span></tt> the argument order does not matter anymore. Mixing named arguments with ordered arguments is also possible, but not very readable:</p>
<p><pre class="listing"><span class="Keyword">var</span> <span class="Identifier">w</span> <span class="Operator">=</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">title</span> <span class="Operator">=</span> <span class="StringLit">&quot;My Application&quot;</span><span class="Punctuation">,</span>
                     <span class="Identifier">height</span> <span class="Operator">=</span> <span class="DecNumber">600</span><span class="Punctuation">,</span> <span class="Identifier">width</span> <span class="Operator">=</span> <span class="DecNumber">800</span><span class="Punctuation">,</span> <span class="Identifier">true</span><span class="Punctuation">)</span></pre></p>
<p>The compiler checks that each parameter receives exactly one argument.</p>

<h2><a class="toc-backref" id="procedures-default-values" href="#procedures-default-values">Default values</a></h2><p>To make the <tt class="docutils literal"><span class="pre"><span class="Identifier">createWindow</span></span></tt> proc easier to use it should provide <tt class="docutils literal"><span class="pre"><span class="Identifier">default</span> <span class="Identifier">values</span></span></tt>; these are values that are used as arguments if the caller does not specify them:</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">width</span> <span class="Operator">=</span> <span class="DecNumber">500</span><span class="Punctuation">,</span> <span class="Identifier">height</span> <span class="Operator">=</span> <span class="DecNumber">700</span><span class="Punctuation">,</span>
                  <span class="Identifier">title</span> <span class="Operator">=</span> <span class="StringLit">&quot;unknown&quot;</span><span class="Punctuation">,</span>
                  <span class="Identifier">show</span> <span class="Operator">=</span> <span class="Identifier">true</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Window</span> <span class="Operator">=</span>
   <span class="Operator">...</span>

<span class="Keyword">var</span> <span class="Identifier">w</span> <span class="Operator">=</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="Identifier">title</span> <span class="Operator">=</span> <span class="StringLit">&quot;My Application&quot;</span><span class="Punctuation">,</span> <span class="Identifier">height</span> <span class="Operator">=</span> <span class="DecNumber">600</span><span class="Punctuation">,</span> <span class="Identifier">width</span> <span class="Operator">=</span> <span class="DecNumber">800</span><span class="Punctuation">)</span></pre></p>
<p>Now the call to <tt class="docutils literal"><span class="pre"><span class="Identifier">createWindow</span></span></tt> only needs to set the values that differ from the defaults.</p>
<p>Note that type inference works for parameters with default values; there is no need to write <tt class="docutils literal"><span class="pre"><span class="Identifier">title</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;unknown&quot;</span></span></tt>, for example.</p>

<h2><a class="toc-backref" id="procedures-overloaded-procedures" href="#procedures-overloaded-procedures">Overloaded procedures</a></h2><p>Nim provides the ability to overload procedures similar to C++:</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">toString</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span>
    <span class="Keyword">if</span> <span class="Identifier">x</span> <span class="Operator">&lt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span> <span class="StringLit">&quot;negative&quot;</span>
    <span class="Keyword">elif</span> <span class="Identifier">x</span> <span class="Operator">&gt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span> <span class="StringLit">&quot;positive&quot;</span>
    <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="StringLit">&quot;zero&quot;</span>

<span class="Keyword">proc</span> <span class="Identifier">toString</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span>
    <span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="StringLit">&quot;yep&quot;</span>
    <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="StringLit">&quot;nope&quot;</span>

<span class="Identifier">assert</span> <span class="Identifier">toString</span><span class="Punctuation">(</span><span class="DecNumber">13</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="StringLit">&quot;positive&quot;</span> <span class="Comment"># calls the toString(x: int) proc</span>
<span class="Identifier">assert</span> <span class="Identifier">toString</span><span class="Punctuation">(</span><span class="Identifier">true</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="StringLit">&quot;yep&quot;</span>    <span class="Comment"># calls the toString(x: bool) proc</span></pre></p>
<p>(Note that <tt class="docutils literal"><span class="pre"><span class="Identifier">toString</span></span></tt> is usually the <a class="reference external" href="dollars.html">$</a> operator in Nim.) The compiler chooses the most appropriate proc for the <tt class="docutils literal"><span class="pre"><span class="Identifier">toString</span></span></tt> calls. How this overloading resolution algorithm works exactly is not discussed here -- see the manual for details. Ambiguous calls are reported as errors.</p>

<h2><a class="toc-backref" id="procedures-operators" href="#procedures-operators">Operators</a></h2><p>The Nim standard library makes heavy use of overloading - one reason for this is that each operator like <tt class="docutils literal"><span class="pre"><span class="Operator">+</span></span></tt> is just an overloaded proc. The parser lets you use operators in <em>infix notation</em> (<tt class="docutils literal"><span class="pre"><span class="Identifier">a</span> <span class="Operator">+</span> <span class="Identifier">b</span></span></tt>) or <em>prefix notation</em> (<tt class="docutils literal"><span class="pre"><span class="Operator">+</span> <span class="Identifier">a</span></span></tt>). An infix operator always receives two arguments, a prefix operator always one. (Postfix operators are not possible, because this would be ambiguous: does <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span> <span class="Operator">@</span> <span class="Operator">@</span> <span class="Identifier">b</span></span></tt> mean <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">@</span> <span class="Punctuation">(</span><span class="Operator">@</span><span class="Identifier">b</span><span class="Punctuation">)</span></span></tt> or <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">@</span><span class="Punctuation">)</span> <span class="Operator">@</span> <span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span></span></tt>? It always means <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">@</span> <span class="Punctuation">(</span><span class="Operator">@</span><span class="Identifier">b</span><span class="Punctuation">)</span></span></tt>, because there are no postfix operators in Nim.)</p>
<p>Apart from a few built-in keyword operators such as <tt class="docutils literal"><span class="pre"><span class="Keyword">and</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">or</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">not</span></span></tt>, operators always consist of these characters: <tt class="docutils literal"><span class="pre"><span class="Operator">+</span> <span class="Operator">-</span> <span class="Operator">*</span> <span class="Operator">\</span> <span class="Operator">/</span> <span class="Operator">&lt;</span> <span class="Operator">&gt;</span> <span class="Operator">=</span> <span class="Operator">@</span> <span class="Operator">$</span> <span class="Operator">~</span> <span class="Operator">&amp;</span> <span class="Operator">%</span> <span class="Operator">!</span> <span class="Operator">?</span> <span class="Operator">^</span> <span class="Operator">.</span> <span class="Operator">|</span></span></tt></p>
<p>User-defined operators are allowed. Nothing stops you from defining your own <tt class="docutils literal"><span class="pre"><span class="Operator">@!?+~</span></span></tt> operator, but doing so may reduce readability.</p>
<p>The operator's precedence is determined by its first character. The details can be <a class="reference external" href="manual.html#syntax-precedence">found in the manual</a>.</p>
<p>To define a new operator enclose the operator in backticks &quot;`&quot;:</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">myDataType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">...</span>
<span class="Comment"># now the $ operator also works with myDataType, overloading resolution</span>
<span class="Comment"># ensures that $ works for built-in types just like before</span></pre></p>
<p>The &quot;`&quot; notation can also be used to call an operator just like any other procedure:</p>
<p><pre class="listing"><span class="Keyword">if</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span><span class="Punctuation">(</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="DecNumber">7</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;true&quot;</span></pre></p>

<h2><a class="toc-backref" id="procedures-forward-declarations" href="#procedures-forward-declarations">Forward declarations</a></h2><p>Every variable, procedure, etc. needs to be declared before it can be used. (The reason for this is that it is non-trivial to avoid this need in a language that supports metaprogramming as extensively as Nim does.) However, this cannot be done for mutually recursive procedures:</p>
<p><pre class="listing"><span class="Comment"># forward declaration:</span>
<span class="Keyword">proc</span> <span class="Identifier">even</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span></pre></p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">odd</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">n</span> <span class="Operator">&gt;=</span> <span class="DecNumber">0</span><span class="Punctuation">)</span> <span class="Comment"># makes sure we don't run into negative recursion</span>
  <span class="Keyword">if</span> <span class="Identifier">n</span> <span class="Operator">==</span> <span class="DecNumber">0</span><span class="Punctuation">:</span> <span class="Identifier">false</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">n</span> <span class="Operator">==</span> <span class="DecNumber">1</span> <span class="Keyword">or</span> <span class="Identifier">even</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">even</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">n</span> <span class="Operator">&gt;=</span> <span class="DecNumber">0</span><span class="Punctuation">)</span> <span class="Comment"># makes sure we don't run into negative recursion</span>
  <span class="Keyword">if</span> <span class="Identifier">n</span> <span class="Operator">==</span> <span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">false</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">n</span> <span class="Operator">==</span> <span class="DecNumber">0</span> <span class="Keyword">or</span> <span class="Identifier">odd</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">)</span></pre></p>
<p>Here <tt class="docutils literal"><span class="pre"><span class="Identifier">odd</span></span></tt> depends on <tt class="docutils literal"><span class="pre"><span class="Identifier">even</span></span></tt> and vice versa. Thus <tt class="docutils literal"><span class="pre"><span class="Identifier">even</span></span></tt> needs to be introduced to the compiler before it is completely defined. The syntax for such a forward declaration is simple: just omit the <tt class="docutils literal"><span class="pre"><span class="Operator">=</span></span></tt> and the procedure's body. The <tt class="docutils literal"><span class="pre"><span class="Identifier">assert</span></span></tt> just adds border conditions, and will be covered later in <a class="reference internal" href="#modules">Modules</a> section.</p>
<p>Later versions of the language will weaken the requirements for forward declarations.</p>
<p>The example also shows that a proc's body can consist of a single expression whose value is then returned implicitly.</p>

<h2><a class="toc-backref" id="procedures-funcs-and-methods" href="#procedures-funcs-and-methods">Funcs and methods</a></h2><p>As mentioned in the introduction, Nim differentiates between procedures, functions, and methods, defined by the <tt class="docutils literal"><span class="pre"><span class="Keyword">proc</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">func</span></span></tt>, and <tt class="docutils literal"><span class="pre"><span class="Keyword">method</span></span></tt> keywords respectively. In some ways, Nim is a bit more pedantic in its definitions than other languages.</p>
<p>Functions are closer to the concept of a pure mathematical function, which might be familiar to you if you've ever done functional programming. Essentially they are procedures with additional limitations set on them: they can't access global state (except <tt class="docutils literal"><span class="pre"><span class="Keyword">const</span></span></tt>) and can't produce side-effects. The <tt class="docutils literal"><span class="pre"><span class="Keyword">func</span></span></tt> keyword is basically an alias for <tt class="docutils literal"><span class="pre"><span class="Keyword">proc</span></span></tt> tagged with <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">noSideEffects</span><span class="Operator">.</span><span class="Punctuation">}</span></span></tt>. Functions can still change their mutable arguments however, which are those marked as <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt>, along with any <tt class="docutils literal"><span class="pre"><span class="Keyword">ref</span></span></tt> objects.</p>
<p>Unlike procedures, methods are dynamically dispatched. This sounds a bit complicated, but it is a concept closely related to inheritance and object-oriented programming. If you overload a procedure (two procedures with the same name but of different types or with different sets of arguments are said to be overloaded), the procedure to use is determined at compile-time. Methods, on the other hand, depend on objects that inherit from the <tt class="docutils literal"><span class="pre"><span class="Identifier">RootObj</span></span></tt>. This is something that is covered in much greater depth in the <a class="reference external" href="tut2.html#object-oriented-programming-dynamic-dispatch">second part of the tutorial</a>.</p>

<h1><a class="toc-backref" id="iterators" href="#iterators">Iterators</a></h1><p>Let's return to the simple counting example:</p>
<p><pre class="listing"><span class="Identifier">echo</span> <span class="StringLit">&quot;Counting to ten: &quot;</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">countup</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">10</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span></pre></p>
<p>Can a <a class="reference external" href="system.html#countup.i,T,T,Positive">countup</a> proc be written that supports this loop? Let's try:</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">countup</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">res</span> <span class="Operator">=</span> <span class="Identifier">a</span>
  <span class="Keyword">while</span> <span class="Identifier">res</span> <span class="Operator">&lt;=</span> <span class="Identifier">b</span><span class="Punctuation">:</span>
    <span class="Keyword">return</span> <span class="Identifier">res</span>
    <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">res</span><span class="Punctuation">)</span></pre></p>
<p>However, this does not work. The problem is that the procedure should not only <tt class="docutils literal"><span class="pre"><span class="Keyword">return</span></span></tt>, but return and <strong>continue</strong> after an iteration has finished. This <em>return and continue</em> is called a <tt class="docutils literal"><span class="pre"><span class="Keyword">yield</span></span></tt> statement. Now the only thing left to do is to replace the <tt class="docutils literal"><span class="pre"><span class="Keyword">proc</span></span></tt> keyword by <tt class="docutils literal"><span class="pre"><span class="Keyword">iterator</span></span></tt> and here it is -- our first iterator:</p>
<p><pre class="listing"><span class="Keyword">iterator</span> <span class="Identifier">countup</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">res</span> <span class="Operator">=</span> <span class="Identifier">a</span>
  <span class="Keyword">while</span> <span class="Identifier">res</span> <span class="Operator">&lt;=</span> <span class="Identifier">b</span><span class="Punctuation">:</span>
    <span class="Keyword">yield</span> <span class="Identifier">res</span>
    <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">res</span><span class="Punctuation">)</span></pre></p>
<p>Iterators look very similar to procedures, but there are several important differences:</p>
<ul class="simple"><li>Iterators can only be called from for loops.</li>
<li>Iterators cannot contain a <tt class="docutils literal"><span class="pre"><span class="Keyword">return</span></span></tt> statement (and procs cannot contain a <tt class="docutils literal"><span class="pre"><span class="Keyword">yield</span></span></tt> statement).</li>
<li>Iterators have no implicit <tt class="docutils literal"><span class="pre"><span class="Identifier">result</span></span></tt> variable.</li>
<li>Iterators do not support recursion.</li>
<li>Iterators cannot be forward declared, because the compiler must be able to inline an iterator. (This restriction will be gone in a future version of the compiler.)</li>
</ul>
<p>However, you can also use a closure iterator to get a different set of restrictions. See <a class="reference external" href=" manual.html#iterators-and-the-for-statement-firstminusclass-iterators">first-class iterators</a> for details. Iterators can have the same name and parameters as a proc since essentially they have their own namespaces. Therefore, it is common to wrap iterators in procs of the same name which accumulate the result of the iterator and return it as a sequence, like <tt class="docutils literal"><span class="pre"><span class="Identifier">split</span></span></tt> from the <a class="reference external" href=" strutils.html">strutils module</a>.</p>

<h1><a class="toc-backref" id="basic-types" href="#basic-types">Basic types</a></h1><p>This section deals with the basic built-in types and the operations that are available for them in detail.</p>

<h2><a class="toc-backref" id="basic-types-booleans" href="#basic-types-booleans">Booleans</a></h2><p>Nim's boolean type is called <tt class="docutils literal"><span class="pre"><span class="Identifier">bool</span></span></tt> and consists of the two pre-defined values <tt class="docutils literal"><span class="pre"><span class="Identifier">true</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">false</span></span></tt>. Conditions in <tt class="docutils literal"><span class="pre"><span class="Keyword">while</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">if</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">elif</span></span></tt>, and <tt class="docutils literal"><span class="pre"><span class="Keyword">when</span></span></tt> statements must be of type bool.</p>
<p>The operators <tt class="docutils literal"><span class="pre"><span class="Keyword">not</span><span class="Punctuation">,</span> <span class="Keyword">and</span><span class="Punctuation">,</span> <span class="Keyword">or</span><span class="Punctuation">,</span> <span class="Keyword">xor</span><span class="Punctuation">,</span> <span class="Operator">&lt;</span><span class="Punctuation">,</span> <span class="Operator">&lt;=</span><span class="Punctuation">,</span> <span class="Operator">&gt;</span><span class="Punctuation">,</span> <span class="Operator">&gt;=</span><span class="Punctuation">,</span> <span class="Operator">!=</span><span class="Punctuation">,</span> <span class="Operator">==</span></span></tt> are defined for the bool type. The <tt class="docutils literal"><span class="pre"><span class="Keyword">and</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Keyword">or</span></span></tt> operators perform short-circuit evaluation. For example:</p>
<p><pre class="listing"><span class="Keyword">while</span> <span class="Identifier">p</span> <span class="Operator">!=</span> <span class="Keyword">nil</span> <span class="Keyword">and</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">name</span> <span class="Operator">!=</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">:</span>
  <span class="Comment"># p.name is not evaluated if p == nil</span>
  <span class="Identifier">p</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">next</span></pre></p>

<h2><a class="toc-backref" id="basic-types-characters" href="#basic-types-characters">Characters</a></h2><p>The <em>character type</em> is called <tt class="docutils literal"><span class="pre"><span class="Identifier">char</span></span></tt>. Its size is always one byte, so it cannot represent most UTF-8 characters, but it <em>can</em> represent one of the bytes that makes up a multibyte UTF-8 character. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was especially designed for this. Character literals are enclosed in single quotes.</p>
<p>Chars can be compared with the <tt class="docutils literal"><span class="pre"><span class="Operator">==</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Operator">&lt;</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Operator">&lt;=</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Operator">&gt;</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Operator">&gt;=</span></span></tt> operators. The <tt class="docutils literal"><span class="pre"><span class="Operator">$</span></span></tt> operator converts a <tt class="docutils literal"><span class="pre"><span class="Identifier">char</span></span></tt> to a <tt class="docutils literal"><span class="pre"><span class="Identifier">string</span></span></tt>. Chars cannot be mixed with integers; to get the ordinal value of a <tt class="docutils literal"><span class="pre"><span class="Identifier">char</span></span></tt> use the <tt class="docutils literal"><span class="pre"><span class="Identifier">ord</span></span></tt> proc. Converting from an integer to a <tt class="docutils literal"><span class="pre"><span class="Identifier">char</span></span></tt> is done with the <tt class="docutils literal"><span class="pre"><span class="Identifier">chr</span></span></tt> proc.</p>

<h2><a class="toc-backref" id="basic-types-strings" href="#basic-types-strings">Strings</a></h2><p>String variables are <strong>mutable</strong>, so appending to a string is possible, and quite efficient. Strings in Nim are both zero-terminated and have a length field. A string's length can be retrieved with the builtin <tt class="docutils literal"><span class="pre"><span class="Identifier">len</span></span></tt> procedure; the length never counts the terminating zero. Accessing the terminating zero is an error, it only exists so that a Nim string can be converted to a <tt class="docutils literal"><span class="pre"><span class="Identifier">cstring</span></span></tt> without doing a copy.</p>
<p>The assignment operator for strings copies the string. You can use the <tt class="docutils literal"><span class="pre"><span class="Operator">&amp;</span></span></tt> operator to concatenate strings and <tt class="docutils literal"><span class="pre"><span class="Identifier">add</span></span></tt> to append to a string.</p>
<p>Strings are compared using their lexicographical order. All the comparison operators are supported. By convention, all strings are UTF-8 encoded, but this is not enforced. For example, when reading strings from binary files, they are merely a sequence of bytes. The index operation <tt class="docutils literal"><span class="pre"><span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></span></tt> means the i-th <em>char</em> of <tt class="docutils literal"><span class="pre"><span class="Identifier">s</span></span></tt>, not the i-th <em>unichar</em>.</p>
<p>A string variable is initialized with the empty string <tt class="docutils literal"><span class="pre"><span class="StringLit">&quot;&quot;</span></span></tt>.</p>

<h2><a class="toc-backref" id="basic-types-integers" href="#basic-types-integers">Integers</a></h2><p>Nim has these integer types built-in: <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span> <span class="Identifier">int8</span> <span class="Identifier">int16</span> <span class="Identifier">int32</span> <span class="Identifier">int64</span> <span class="Identifier">uint</span> <span class="Identifier">uint8</span> <span class="Identifier">uint16</span> <span class="Identifier">uint32</span> <span class="Identifier">uint64</span></span></tt>.</p>
<p>The default integer type is <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt>. Integer literals can have a <em>type suffix</em> to specify a non-default integer type:</p>
<p><pre class="listing"><span class="Keyword">let</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">0</span>     <span class="Comment"># x is of type `int`</span>
  <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">0'i8</span>  <span class="Comment"># y is of type `int8`</span>
  <span class="Identifier">z</span> <span class="Operator">=</span> <span class="DecNumber">0'i32</span> <span class="Comment"># z is of type `int32`</span>
  <span class="Identifier">u</span> <span class="Operator">=</span> <span class="DecNumber">0'</span><span class="Identifier">u</span>   <span class="Comment"># u is of type `uint`</span></pre></p>
<p>Most often integers are used for counting objects that reside in memory, so <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt> has the same size as a pointer.</p>
<p>The common operators <tt class="docutils literal"><span class="pre"><span class="Operator">+</span> <span class="Operator">-</span> <span class="Operator">*</span> <span class="Keyword">div</span> <span class="Keyword">mod</span> <span class="Operator">&lt;</span> <span class="Operator">&lt;=</span> <span class="Operator">==</span> <span class="Operator">!=</span> <span class="Operator">&gt;</span> <span class="Operator">&gt;=</span></span></tt> are defined for integers. The <tt class="docutils literal"><span class="pre"><span class="Keyword">and</span> <span class="Keyword">or</span> <span class="Keyword">xor</span> <span class="Keyword">not</span></span></tt> operators are also defined for integers and provide <em>bitwise</em> operations. Left bit shifting is done with the <tt class="docutils literal"><span class="pre"><span class="Keyword">shl</span></span></tt>, right shifting with the <tt class="docutils literal"><span class="pre"><span class="Keyword">shr</span></span></tt> operator. Bit shifting operators always treat their arguments as <em>unsigned</em>. For <span id="arithmetic-bit-shifts_1">arithmetic bit shifts</span> ordinary multiplication or division can be used.</p>
<p>Unsigned operations all wrap around; they cannot lead to over- or under-flow errors.</p>
<p>Lossless <span id="automatic-type-conversion_1">Automatic type conversion</span> is performed in expressions where different kinds of integer types are used. However, if the type conversion would cause loss of information, the <span id="rangedefect_1">RangeDefect</span> is raised (if the error cannot be detected at compile time).</p>

<h2><a class="toc-backref" id="basic-types-floats" href="#basic-types-floats">Floats</a></h2><p>Nim has these floating-point types built-in: <tt class="docutils literal"><span class="pre"><span class="Identifier">float</span> <span class="Identifier">float32</span> <span class="Identifier">float64</span></span></tt>.</p>
<p>The default float type is <tt class="docutils literal"><span class="pre"><span class="Identifier">float</span></span></tt>. In the current implementation, <tt class="docutils literal"><span class="pre"><span class="Identifier">float</span></span></tt> is always 64-bits.</p>
<p>Float literals can have a <em>type suffix</em> to specify a non-default float type:</p>
<p><pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="FloatNumber">0.0</span>      <span class="Comment"># x is of type `float`</span>
  <span class="Identifier">y</span> <span class="Operator">=</span> <span class="FloatNumber">0.0'f32</span>  <span class="Comment"># y is of type `float32`</span>
  <span class="Identifier">z</span> <span class="Operator">=</span> <span class="FloatNumber">0.0'f64</span>  <span class="Comment"># z is of type `float64`</span></pre></p>
<p>The common operators <tt class="docutils literal"><span class="pre"><span class="Operator">+</span> <span class="Operator">-</span> <span class="Operator">*</span> <span class="Operator">/</span> <span class="Operator">&lt;</span> <span class="Operator">&lt;=</span> <span class="Operator">==</span> <span class="Operator">!=</span> <span class="Operator">&gt;</span> <span class="Operator">&gt;=</span></span></tt> are defined for floats and follow the IEEE-754 standard.</p>
<p>Automatic type conversion in expressions with different kinds of floating-point types is performed: the smaller type is converted to the larger. Integer types are <strong>not</strong> converted to floating-point types automatically, nor vice versa. Use the <a class="reference external" href="system.html#toInt,float">toInt</a> and <a class="reference external" href="system.html#toFloat,int">toFloat</a> procs for these conversions.</p>

<h2><a class="toc-backref" id="basic-types-type-conversion" href="#basic-types-type-conversion">Type Conversion</a></h2><p>Conversion between numerical types is performed by using the type as a function:</p>
<p><pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int32</span> <span class="Operator">=</span> <span class="FloatNumber">1.</span><span class="Identifier">int32</span>   <span class="Comment"># same as calling int32(1)</span>
  <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int8</span>  <span class="Operator">=</span> <span class="Identifier">int8</span><span class="Punctuation">(</span><span class="Punctuation">'</span><span class="Identifier">a</span><span class="CharLit">') # '</span><span class="Identifier">a</span><span class="CharLit">' == 97'</span><span class="Identifier">i8</span>
  <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span> <span class="FloatNumber">2.5</span>       <span class="Comment"># int(2.5) rounds down to 2</span>
  <span class="Identifier">sum</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">z</span><span class="Punctuation">)</span> <span class="Comment"># sum == 100</span></pre></p>

<h1><a class="toc-backref" id="internal-type-representation" href="#internal-type-representation">Internal type representation</a></h1><p>As mentioned earlier, the built-in <a class="reference external" href="dollars.html">$</a> (stringify) operator turns any basic type into a string, which you can then print to the console using the <tt class="docutils literal"><span class="pre"><span class="Identifier">echo</span></span></tt> proc. However, advanced types, and your own custom types, won't work with the <tt class="docutils literal"><span class="pre"><span class="Operator">$</span></span></tt> operator until you define it for them. Sometimes you just want to debug the current value of a complex type without having to write its <tt class="docutils literal"><span class="pre"><span class="Operator">$</span></span></tt> operator.  You can use then the <a class="reference external" href=" system.html#repr,T">repr</a> proc which works with any type and even complex data graphs with cycles. The following example shows that even for basic types there is a difference between the <tt class="docutils literal"><span class="pre"><span class="Operator">$</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">repr</span></span></tt> outputs:</p>
<p><pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">myBool</span> <span class="Operator">=</span> <span class="Identifier">true</span>
  <span class="Identifier">myCharacter</span> <span class="Operator">=</span> <span class="CharLit">'n'</span>
  <span class="Identifier">myString</span> <span class="Operator">=</span> <span class="StringLit">&quot;nim&quot;</span>
  <span class="Identifier">myInteger</span> <span class="Operator">=</span> <span class="DecNumber">42</span>
  <span class="Identifier">myFloat</span> <span class="Operator">=</span> <span class="FloatNumber">3.14</span>
<span class="Identifier">echo</span> <span class="Identifier">myBool</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myBool</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; true:true</span>
<span class="Identifier">echo</span> <span class="Identifier">myCharacter</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myCharacter</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; n:'n'</span>
<span class="Identifier">echo</span> <span class="Identifier">myString</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myString</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; nim:0x10fa8c050&quot;nim&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">myInteger</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myInteger</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; 42:42</span>
<span class="Identifier">echo</span> <span class="Identifier">myFloat</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myFloat</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; 3.14:3.14</span></pre></p>

<h1><a class="toc-backref" id="advanced-types" href="#advanced-types">Advanced types</a></h1><p>In Nim new types can be defined within a <tt class="docutils literal"><span class="pre"><span class="Keyword">type</span></span></tt> statement:</p>
<p><pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">biggestInt</span> <span class="Operator">=</span> <span class="Identifier">int64</span>      <span class="Comment"># biggest integer type that is available</span>
  <span class="Identifier">biggestFloat</span> <span class="Operator">=</span> <span class="Identifier">float64</span>  <span class="Comment"># biggest float type that is available</span></pre></p>
<p>Enumeration and object types may only be defined within a <tt class="docutils literal"><span class="pre"><span class="Keyword">type</span></span></tt> statement.</p>

<h2><a class="toc-backref" id="advanced-types-enumerations" href="#advanced-types-enumerations">Enumerations</a></h2><p>A variable of an enumeration type can only be assigned one of the enumeration's specified values. These values are a set of ordered symbols. Each symbol is mapped to an integer value internally. The first symbol is represented at runtime by 0, the second by 1, and so on. For example:</p>
<p><pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Direction</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">north</span><span class="Punctuation">,</span> <span class="Identifier">east</span><span class="Punctuation">,</span> <span class="Identifier">south</span><span class="Punctuation">,</span> <span class="Identifier">west</span>

<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">south</span>     <span class="Comment"># `x` is of type `Direction`; its value is `south`</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span>            <span class="Comment"># prints &quot;south&quot;</span>

<span class="Keyword">if</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="Identifier">Direction</span><span class="Operator">.</span><span class="Identifier">south</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;It's south!&quot;</span></pre></p>
<p>All the comparison operators can be used with enumeration types.</p>
<p>An enumeration's symbol can be qualified to avoid ambiguities: <tt class="docutils literal"><span class="pre"><span class="Identifier">Direction</span><span class="Operator">.</span><span class="Identifier">south</span></span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre"><span class="Operator">$</span></span></tt> operator can convert any enumeration value to its name, and the <tt class="docutils literal"><span class="pre"><span class="Identifier">ord</span></span></tt> proc can convert it to its underlying integer value.</p>
<p>For better interfacing to other programming languages, the symbols of enum types can be assigned an explicit ordinal value. However, the ordinal values must be in ascending order.</p>

<h2><a class="toc-backref" id="advanced-types-ordinal-types" href="#advanced-types-ordinal-types">Ordinal types</a></h2><p>Enumerations, integer types, <tt class="docutils literal"><span class="pre"><span class="Identifier">char</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">bool</span></span></tt> (and subranges) are called ordinal types. Ordinal types have quite a few special operations:</p>
<table border="1" class="docutils"><tr><th>Operation</th><th>Comment</th></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">ord</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></span></tt></td><td>returns the integer value that is used to represent <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt>'s value</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></span></tt></td><td>increments <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> by one</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span></span></tt></td><td>increments <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> by <tt class="docutils literal"><span class="pre"><span class="Identifier">n</span></span></tt>; <tt class="docutils literal"><span class="pre"><span class="Identifier">n</span></span></tt> is an integer</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">dec</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></span></tt></td><td>decrements <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> by one</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">dec</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span></span></tt></td><td>decrements <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> by <tt class="docutils literal"><span class="pre"><span class="Identifier">n</span></span></tt>; <tt class="docutils literal"><span class="pre"><span class="Identifier">n</span></span></tt> is an integer</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">succ</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></span></tt></td><td>returns the successor of <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">succ</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span></span></tt></td><td>returns the <tt class="docutils literal"><span class="pre"><span class="Identifier">n</span></span></tt>'th successor of <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">pred</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></span></tt></td><td>returns the predecessor of <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">pred</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span></span></tt></td><td>returns the <tt class="docutils literal"><span class="pre"><span class="Identifier">n</span></span></tt>'th predecessor of <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt></td></tr>
</table><p>The <a class="reference external" href="system.html#inc,T,int">inc</a>, <a class="reference external" href="system.html#dec,T,int">dec</a>, <a class="reference external" href=" system.html#succ,T,int">succ</a> and <a class="reference external" href="system.html#pred,T,int">pred</a> operations can fail by raising an <tt class="docutils literal"><span class="pre"><span class="Identifier">RangeDefect</span></span></tt> or <tt class="docutils literal"><span class="pre"><span class="Identifier">OverflowDefect</span></span></tt>. (If the code has been compiled with the proper runtime checks turned on.)</p>

<h2><a class="toc-backref" id="advanced-types-subranges" href="#advanced-types-subranges">Subranges</a></h2><p>A subrange type is a range of values from an integer or enumeration type (the base type). Example:</p>
<p><pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">MySubrange</span> <span class="Operator">=</span> <span class="Identifier">range</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">]</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">MySubrange</span></span></tt> is a subrange of <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt> which can only hold the values 0 to 5. Assigning any other value to a variable of type <tt class="docutils literal"><span class="pre"><span class="Identifier">MySubrange</span></span></tt> is a compile-time or runtime error. Assignments from the base type to one of its subrange types (and vice versa) are allowed.</p>
<p>The <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span></span></tt> module defines the important <a class="reference external" href="system.html#Natural">Natural</a> type as <tt class="docutils literal"><span class="pre"><span class="Identifier">range</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">]</span></span></tt> (<a class="reference external" href="system.html#high,typedesc[T]">high</a> returns the maximal value). Other programming languages may suggest the use of unsigned integers for natural numbers. This is often <strong>unwise</strong>: you don't want unsigned arithmetic (which wraps around) just because the numbers cannot be negative. Nim's <tt class="docutils literal"><span class="pre"><span class="Identifier">Natural</span></span></tt> type helps to avoid this common programming error.</p>

<h2><a class="toc-backref" id="advanced-types-sets" href="#advanced-types-sets">Sets</a></h2>The set type models the mathematical notion of a set. The set's basetype can only be an ordinal type of a certain size, namely:<ul class="simple"><li><tt class="docutils literal"><span class="pre"><span class="Identifier">int8</span></span></tt>-<tt class="docutils literal"><span class="pre"><span class="Identifier">int16</span></span></tt></li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">uint8</span></span></tt>/<tt class="docutils literal"><span class="pre"><span class="Identifier">byte</span></span></tt>-<tt class="docutils literal"><span class="pre"><span class="Identifier">uint16</span></span></tt></li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">char</span></span></tt></li>
<li><tt class="docutils literal"><span class="pre"><span class="Keyword">enum</span></span></tt></li>
<li>Ordinal subrange types, i.e. <tt class="docutils literal"><span class="pre"><span class="Identifier">range</span><span class="Punctuation">[</span><span class="Operator">-</span><span class="FloatNumber">10.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">]</span></span></tt></li>
</ul>
<p>or equivalent. When constructing a set with signed integer literals, the set's base type is defined to be in the range <tt class="docutils literal"><span class="pre"><span class="DecNumber">0</span> <span class="Operator">..</span> <span class="Identifier">DefaultSetElements</span><span class="Operator">-</span><span class="DecNumber">1</span></span></tt> where <tt class="docutils literal"><span class="pre"><span class="Identifier">DefaultSetElements</span></span></tt> is currently always 2^8. The maximum range length for the base type of a set is <tt class="docutils literal"><span class="pre"><span class="Identifier">MaxSetElements</span></span></tt> which is currently always 2^16. Types with a bigger range length are coerced into the range <tt class="docutils literal"><span class="pre"><span class="DecNumber">0</span> <span class="Operator">..</span> <span class="Identifier">MaxSetElements</span><span class="Operator">-</span><span class="DecNumber">1</span></span></tt>.</p>
<p>The reason is that sets are implemented as high performance bit vectors. Attempting to declare a set with a larger type will result in an error:</p>
<p><pre class="listing">  <span class="Keyword">var</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">int64</span><span class="Punctuation">]</span> <span class="Comment"># Error: set is too large; use `std/sets` for ordinal types</span>
                    <span class="Comment"># with more than 2^16 elements</span></pre></p>
<p><strong>Note:</strong> Nim also offers <a class="reference external" href="sets.html">hash sets</a> (which you need to import with <tt class="docutils literal"><span class="pre"><span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">sets</span></span></tt>), which have no such restrictions.</p>
<p>Sets can be constructed via the set constructor: <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Punctuation">}</span></span></tt> is the empty set. The empty set is type compatible with any concrete set type. The constructor can also be used to include elements (and ranges of elements):</p>
<p><pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">CharSet</span> <span class="Operator">=</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">char</span><span class="Punctuation">]</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">CharSet</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">{</span><span class="Punctuation">'</span><span class="Identifier">a</span><span class="CharLit">'..'</span><span class="Identifier">z</span><span class="CharLit">', '</span><span class="DecNumber">0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">}</span> <span class="Comment"># This constructs a set that contains the</span>
                         <span class="Comment"># letters from 'a' to 'z' and the digits</span>
                         <span class="Comment"># from '0' to '9'</span></pre></p>
<p>The module <a class="reference external" href="setutils.html">`std/setutils`</a> provides a way to initialize a set from an iterable:</p>
<p><pre class="listing"><span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">setutils</span>

<span class="Keyword">let</span> <span class="Identifier">uniqueChars</span> <span class="Operator">=</span> <span class="Identifier">myString</span><span class="Operator">.</span><span class="Identifier">toSet</span></pre></p>
<p>These operations are supported by sets:</p>
<table border="1" class="docutils"><tr><th>operation</th><th>meaning</th></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">+</span> <span class="Identifier">B</span></span></tt></td><td>union of two sets</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">*</span> <span class="Identifier">B</span></span></tt></td><td>intersection of two sets</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">-</span> <span class="Identifier">B</span></span></tt></td><td>difference of two sets (A without B's elements)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">==</span> <span class="Identifier">B</span></span></tt></td><td>set equality</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">&lt;=</span> <span class="Identifier">B</span></span></tt></td><td>subset relation (A is subset of B or equal to B)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">&lt;</span> <span class="Identifier">B</span></span></tt></td><td>strict subset relation (A is a proper subset of B)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">e</span> <span class="Keyword">in</span> <span class="Identifier">A</span></span></tt></td><td>set membership (A contains element e)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">e</span> <span class="Keyword">notin</span> <span class="Identifier">A</span></span></tt></td><td>A does not contain element e</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">contains</span><span class="Punctuation">(</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">e</span><span class="Punctuation">)</span></span></tt></td><td>A contains element e</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">card</span><span class="Punctuation">(</span><span class="Identifier">A</span><span class="Punctuation">)</span></span></tt></td><td>the cardinality of A (number of elements in A)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">incl</span><span class="Punctuation">(</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">elem</span><span class="Punctuation">)</span></span></tt></td><td>same as <tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">=</span> <span class="Identifier">A</span> <span class="Operator">+</span> <span class="Punctuation">{</span><span class="Identifier">elem</span><span class="Punctuation">}</span></span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">excl</span><span class="Punctuation">(</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">elem</span><span class="Punctuation">)</span></span></tt></td><td>same as <tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">=</span> <span class="Identifier">A</span> <span class="Operator">-</span> <span class="Punctuation">{</span><span class="Identifier">elem</span><span class="Punctuation">}</span></span></tt></td></tr>
</table>
<h3><a class="toc-backref" id="sets-bit-fields" href="#sets-bit-fields">Bit fields</a></h3><p>Sets are often used to define a type for the <em>flags</em> of a procedure. This is a cleaner (and type safe) solution than defining integer constants that have to be <tt class="docutils literal"><span class="pre"><span class="Keyword">or</span></span></tt>'ed together.</p>
<p>Enum, sets and casting can be used together as in:</p>
<p><pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">MyFlag</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">size</span><span class="Punctuation">:</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">cint</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">A</span>
    <span class="Identifier">B</span>
    <span class="Identifier">C</span>
    <span class="Identifier">D</span>
  <span class="Identifier">MyFlags</span> <span class="Operator">=</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">MyFlag</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">MyFlags</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">cint</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
<span class="Keyword">proc</span> <span class="Identifier">toFlags</span><span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">MyFlags</span> <span class="Operator">=</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">MyFlags</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">)</span>

<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">0</span>
<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Identifier">A</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Identifier">D</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">8</span>
<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">C</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">5</span>
<span class="Identifier">assert</span> <span class="Identifier">toFlags</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="Punctuation">{</span><span class="Punctuation">}</span>
<span class="Identifier">assert</span> <span class="Identifier">toFlags</span><span class="Punctuation">(</span><span class="DecNumber">7</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="Punctuation">{</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span><span class="Punctuation">,</span> <span class="Identifier">C</span><span class="Punctuation">}</span></pre></p>
<p>Note how the set turns enum values into powers of 2.</p>
<p>If using enums and sets with C, use distinct cint.</p>
<p>For interoperability with C see also the <a class="reference external" href="manual.html#implementation-specific-pragmas-bitsize-pragma">bitsize pragma</a>. </p>

<h2><a class="toc-backref" id="advanced-types-arrays" href="#advanced-types-arrays">Arrays</a></h2><p>An array is a simple fixed-length container. Each element in an array has the same type. The array's index type can be any ordinal type.</p>
<p>Arrays can be constructed using <tt class="docutils literal"><span class="pre"><span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt>:</p>
<p><pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">IntArray</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># an array that is indexed with 0..5</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">IntArray</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">low</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Operator">..</span> <span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></pre></p>
<p>The notation <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></span></tt> is used to access the i-th element of <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt>. Array access is always bounds checked (at compile-time or at runtime). These checks can be disabled via pragmas or invoking the compiler with the <tt class="docutils literal"><span class="pre">--bound_checks:off</span></tt> command line switch.</p>
<p>Arrays are value types, like any other Nim type. The assignment operator copies the whole array contents.</p>
<p>The built-in <a class="reference external" href="system.html#len,TOpenArray">len</a> proc returns the array's length. <a class="reference external" href="system.html#low,openArray[T]">low(a)</a> returns the lowest valid index for the array <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> and <a class="reference external" href="system.html#high,openArray[T]">high(a)</a> the highest valid index.</p>
<p><pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Direction</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">north</span><span class="Punctuation">,</span> <span class="Identifier">east</span><span class="Punctuation">,</span> <span class="Identifier">south</span><span class="Punctuation">,</span> <span class="Identifier">west</span>
  <span class="Identifier">BlinkLights</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">off</span><span class="Punctuation">,</span> <span class="Identifier">on</span><span class="Punctuation">,</span> <span class="Identifier">slowBlink</span><span class="Punctuation">,</span> <span class="Identifier">mediumBlink</span><span class="Punctuation">,</span> <span class="Identifier">fastBlink</span>
  <span class="Identifier">LevelSetting</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="Identifier">north</span><span class="Operator">..</span><span class="Identifier">west</span><span class="Punctuation">,</span> <span class="Identifier">BlinkLights</span><span class="Punctuation">]</span>
<span class="Keyword">var</span>
  <span class="Identifier">level</span><span class="Punctuation">:</span> <span class="Identifier">LevelSetting</span>
<span class="Identifier">level</span><span class="Punctuation">[</span><span class="Identifier">north</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">on</span>
<span class="Identifier">level</span><span class="Punctuation">[</span><span class="Identifier">south</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">slowBlink</span>
<span class="Identifier">level</span><span class="Punctuation">[</span><span class="Identifier">east</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">fastBlink</span>
<span class="Identifier">echo</span> <span class="Identifier">level</span>        <span class="Comment"># --&gt; [on, fastBlink, slowBlink, off]</span>
<span class="Identifier">echo</span> <span class="Identifier">low</span><span class="Punctuation">(</span><span class="Identifier">level</span><span class="Punctuation">)</span>   <span class="Comment"># --&gt; north</span>
<span class="Identifier">echo</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">level</span><span class="Punctuation">)</span>   <span class="Comment"># --&gt; 4</span>
<span class="Identifier">echo</span> <span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">level</span><span class="Punctuation">)</span>  <span class="Comment"># --&gt; west</span></pre></p>
<p>The syntax for nested arrays (multidimensional) in other languages is a matter of appending more brackets because usually each dimension is restricted to the same index type as the others. In Nim you can have different dimensions with different index types, so the nesting syntax is slightly different. Building on the previous example where a level is defined as an array of enums indexed by yet another enum, we can add the following lines to add a light tower type subdivided into height levels accessed through their integer index:</p>
<p><pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">LightTower</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">1.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Identifier">LevelSetting</span><span class="Punctuation">]</span>
<span class="Keyword">var</span>
  <span class="Identifier">tower</span><span class="Punctuation">:</span> <span class="Identifier">LightTower</span>
<span class="Identifier">tower</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">[</span><span class="Identifier">north</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">slowBlink</span>
<span class="Identifier">tower</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">[</span><span class="Identifier">east</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">mediumBlink</span>
<span class="Identifier">echo</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">tower</span><span class="Punctuation">)</span>     <span class="Comment"># --&gt; 10</span>
<span class="Identifier">echo</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">tower</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span>  <span class="Comment"># --&gt; 4</span>
<span class="Identifier">echo</span> <span class="Identifier">tower</span>          <span class="Comment"># --&gt; [[slowBlink, mediumBlink, ...more output..</span>
<span class="Comment"># The following lines don't compile due to type mismatch errors</span>
<span class="Comment">#tower[north][east] = on</span>
<span class="Comment">#tower[0][1] = on</span></pre></p>
<p>Note how the built-in <tt class="docutils literal"><span class="pre"><span class="Identifier">len</span></span></tt> proc returns only the array's first dimension length.  Another way of defining the <tt class="docutils literal"><span class="pre"><span class="Identifier">LightTower</span></span></tt> to better illustrate its nested nature would be to omit the previous definition of the <tt class="docutils literal"><span class="pre"><span class="Identifier">LevelSetting</span></span></tt> type and instead write it embedded directly as the type of the first dimension:</p>
<p><pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">LightTower</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">1.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="Identifier">north</span><span class="Operator">..</span><span class="Identifier">west</span><span class="Punctuation">,</span> <span class="Identifier">BlinkLights</span><span class="Punctuation">]</span><span class="Punctuation">]</span></pre></p>
<p>It is quite common to have arrays start at zero, so there's a shortcut syntax to specify a range from zero to the specified index minus one:</p>
<p><pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">IntArray</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># an array that is indexed with 0..5</span>
  <span class="Identifier">QuickArray</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="DecNumber">6</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>  <span class="Comment"># an array that is indexed with 0..5</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">IntArray</span>
  <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">QuickArray</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span>
<span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">x</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">low</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Operator">..</span> <span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></pre></p>

<h2><a class="toc-backref" id="advanced-types-sequences" href="#advanced-types-sequences">Sequences</a></h2><p>Sequences are similar to arrays but of dynamic length which may change during runtime (like strings). Since sequences are resizable they are always allocated on the heap and garbage collected.</p>
<p>Sequences are always indexed with an <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt> starting at position 0.  The <a class="reference external" href=" system.html#len,seq[T]">len</a>, <a class="reference external" href="system.html#low,openArray[T]">low</a> and <a class="reference external" href=" system.html#high,openArray[T]">high</a> operations are available for sequences too. The notation <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></span></tt> can be used to access the i-th element of <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt>.</p>
<p>Sequences can be constructed by the array constructor <tt class="docutils literal"><span class="pre"><span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt> in conjunction with the array to sequence operator <tt class="docutils literal"><span class="pre"><span class="Operator">@</span></span></tt>. Another way to allocate space for a sequence is to call the built-in <a class="reference external" href="system.html#newSeq">newSeq</a> procedure.</p>
<p>A sequence may be passed to an openarray parameter.</p>
<p>Example:</p>
<p><pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># a reference to a sequence of integers</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span> <span class="Comment"># the @ turns the array into a sequence allocated on the heap</span></pre></p>
<p>Sequence variables are initialized with <tt class="docutils literal"><span class="pre"><span class="Operator">@</span><span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre"><span class="Keyword">for</span></span></tt> statement can be used with one or two variables when used with a sequence. When you use the one variable form, the variable will hold the value provided by the sequence. The <tt class="docutils literal"><span class="pre"><span class="Keyword">for</span></span></tt> statement is looping over the results from the <a class="reference external" href="iterators.html#items.i,seq[T]">items()</a> iterator from the <a class="reference external" href=" system.html">system</a> module.  But if you use the two-variable form, the first variable will hold the index position and the second variable will hold the value. Here the <tt class="docutils literal"><span class="pre"><span class="Keyword">for</span></span></tt> statement is looping over the results from the <a class="reference external" href="iterators.html#pairs.i,seq[T]">pairs()</a> iterator from the <a class="reference external" href=" system.html">system</a> module.  Examples:</p>
<p><pre class="listing"><span class="Keyword">for</span> <span class="Identifier">value</span> <span class="Keyword">in</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">]</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">value</span>
<span class="Comment"># --&gt; 3</span>
<span class="Comment"># --&gt; 4</span>
<span class="Comment"># --&gt; 5</span>

<span class="Keyword">for</span> <span class="Identifier">i</span><span class="Punctuation">,</span> <span class="Identifier">value</span> <span class="Keyword">in</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">]</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;index: &quot;</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="Identifier">i</span><span class="Punctuation">,</span> <span class="StringLit">&quot;, value:&quot;</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="Identifier">value</span>
<span class="Comment"># --&gt; index: 0, value:3</span>
<span class="Comment"># --&gt; index: 1, value:4</span>
<span class="Comment"># --&gt; index: 2, value:5</span></pre></p>

<h2><a class="toc-backref" id="advanced-types-open-arrays" href="#advanced-types-open-arrays">Open arrays</a></h2><p><strong>Note</strong>: Openarrays can only be used for parameters.</p>
<p>Often fixed-size arrays turn out to be too inflexible; procedures should be able to deal with arrays of different sizes. The <span id="openarray_1">openarray</span> type allows this. Openarrays are always indexed with an <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt> starting at position 0. The <a class="reference external" href="system.html#len,TOpenArray">len</a>, <a class="reference external" href="system.html#low,openArray[T]">low</a> and <a class="reference external" href="system.html#high,openArray[T]">high</a> operations are available for open arrays too.  Any array with a compatible base type can be passed to an openarray parameter, the index type does not matter.</p>
<p><pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">fruits</span><span class="Punctuation">:</span>   <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span>       <span class="Comment"># reference to a sequence of strings that is initialized with '@[]'</span>
  <span class="Identifier">capitals</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="Identifier">string</span><span class="Punctuation">]</span>  <span class="Comment"># array of strings with a fixed size</span>

<span class="Identifier">capitals</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="StringLit">&quot;New York&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;London&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Berlin&quot;</span><span class="Punctuation">]</span>   <span class="Comment"># array 'capitals' allows assignment of only three elements</span>
<span class="Identifier">fruits</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="StringLit">&quot;Banana&quot;</span><span class="Punctuation">)</span>          <span class="Comment"># sequence 'fruits' is dynamically expandable during runtime</span>
<span class="Identifier">fruits</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="StringLit">&quot;Mango&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">openArraySize</span><span class="Punctuation">(</span><span class="Identifier">oa</span><span class="Punctuation">:</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">oa</span><span class="Operator">.</span><span class="Identifier">len</span>

<span class="Identifier">assert</span> <span class="Identifier">openArraySize</span><span class="Punctuation">(</span><span class="Identifier">fruits</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">2</span>     <span class="Comment"># procedure accepts a sequence as parameter</span>
<span class="Identifier">assert</span> <span class="Identifier">openArraySize</span><span class="Punctuation">(</span><span class="Identifier">capitals</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">3</span>   <span class="Comment"># but also an array type</span></pre></p>
<p>The openarray type cannot be nested: multidimensional openarrays are not supported because this is seldom needed and cannot be done efficiently.</p>

<h2><a class="toc-backref" id="advanced-types-varargs" href="#advanced-types-varargs">Varargs</a></h2><p>A <tt class="docutils literal"><span class="pre"><span class="Identifier">varargs</span></span></tt> parameter is like an openarray parameter. However, it is also a means to implement passing a variable number of arguments to a procedure. The compiler converts the list of arguments to an array automatically:</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">s</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
  <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">)</span>
<span class="Comment"># is transformed by the compiler to:</span>
<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Punctuation">[</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre></p>
<p>This transformation is only done if the varargs parameter is the last parameter in the procedure header. It is also possible to perform type conversions in this context:</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">s</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
  <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="DecNumber">123</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="FloatNumber">4.0</span><span class="Punctuation">)</span>
<span class="Comment"># is transformed by the compiler to:</span>
<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Punctuation">[</span><span class="Operator">$</span><span class="DecNumber">123</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="FloatNumber">4.0</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre></p>
<p>In this example <a class="reference external" href="dollars.html">$</a> is applied to any argument that is passed to the parameter <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt>. Note that <a class="reference external" href="dollars.html">$</a> applied to strings is a nop.</p>

<h2><a class="toc-backref" id="advanced-types-slices" href="#advanced-types-slices">Slices</a></h2><p>Slices look similar to subranges types in syntax but are used in a different context. A slice is just an object of type Slice which contains two bounds, <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span></span></tt>. By itself a slice is not very useful, but other collection types define operators which accept Slice objects to define ranges.</p>
<p><pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">a</span> <span class="Operator">=</span> <span class="StringLit">&quot;Nim is a programming language&quot;</span>
  <span class="Identifier">b</span> <span class="Operator">=</span> <span class="StringLit">&quot;Slices are useless.&quot;</span>

<span class="Identifier">echo</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">7</span> <span class="Operator">..</span> <span class="DecNumber">12</span><span class="Punctuation">]</span> <span class="Comment"># --&gt; 'a prog'</span>
<span class="Identifier">b</span><span class="Punctuation">[</span><span class="DecNumber">11</span> <span class="Operator">..</span> <span class="Operator">^</span><span class="DecNumber">2</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="StringLit">&quot;useful&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">b</span> <span class="Comment"># --&gt; 'Slices are useful.'</span></pre></p>
<p>In the previous example slices are used to modify a part of a string. The slice's bounds can hold any value supported by their type, but it is the proc using the slice object which defines what values are accepted.</p>
<p>To understand the different ways of specifying the indices of strings, arrays, sequences, etc., it must be remembered that Nim uses zero-based indices.</p>
<p>So the string <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span></span></tt> is of length 19, and two different ways of specifying the indices are</p>
<p><pre class="listing"><span class="StringLit">&quot;Slices are useless.&quot;</span>
 <span class="Operator">|</span>          <span class="Operator">|</span>     <span class="Operator">|</span>
 <span class="DecNumber">0</span>         <span class="DecNumber">11</span>    <span class="DecNumber">17</span>   <span class="Keyword">using</span> <span class="Identifier">indices</span>
<span class="Operator">^</span><span class="DecNumber">19</span>        <span class="Operator">^</span><span class="DecNumber">8</span>    <span class="Operator">^</span><span class="DecNumber">2</span>   <span class="Keyword">using</span> <span class="Operator">^</span> <span class="Identifier">syntax</span></pre></p>
<p>where <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span><span class="Punctuation">[</span><span class="DecNumber">0</span> <span class="Operator">..</span> <span class="Operator">^</span><span class="DecNumber">1</span><span class="Punctuation">]</span></span></tt> is equivalent to <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span><span class="Punctuation">[</span><span class="DecNumber">0</span> <span class="Operator">..</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">]</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span><span class="Punctuation">[</span><span class="DecNumber">0</span> <span class="Operator">..&lt;</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">]</span></span></tt>, and it can be seen that the <tt class="docutils literal"><span class="pre"><span class="Operator">^</span><span class="DecNumber">1</span></span></tt> provides a shorthand way of specifying the <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Operator">-</span><span class="DecNumber">1</span></span></tt>. See the <a class="reference external" href="system.html#^.t%2Cint">backwards index operator</a>.</p>
<p>In the above example, because the string ends in a period, to get the portion of the string that is &quot;useless&quot; and replace it with &quot;useful&quot;.</p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">b</span><span class="Punctuation">[</span><span class="DecNumber">11</span> <span class="Operator">..</span> <span class="Operator">^</span><span class="DecNumber">2</span><span class="Punctuation">]</span></span></tt> is the portion &quot;useless&quot;, and <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span><span class="Punctuation">[</span><span class="DecNumber">11</span> <span class="Operator">..</span> <span class="Operator">^</span><span class="DecNumber">2</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="StringLit">&quot;useful&quot;</span></span></tt> replaces the &quot;useless&quot; portion with &quot;useful&quot;, giving the result &quot;Slices are useful.&quot;</p>
<p>Note 1: alternate ways of writing this are <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span><span class="Punctuation">[</span><span class="Operator">^</span><span class="DecNumber">8</span> <span class="Operator">..</span> <span class="Operator">^</span><span class="DecNumber">2</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="StringLit">&quot;useful&quot;</span></span></tt> or as <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span><span class="Punctuation">[</span><span class="DecNumber">11</span> <span class="Operator">..</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Operator">-</span><span class="DecNumber">2</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="StringLit">&quot;useful&quot;</span></span></tt> or as <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span><span class="Punctuation">[</span><span class="DecNumber">11</span> <span class="Operator">..&lt;</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="StringLit">&quot;useful&quot;</span></span></tt>.</p>
<p>Note 2: As the <tt class="docutils literal"><span class="pre"><span class="Operator">^</span></span></tt> template returns a <a class="reference external" href="manual.html#types-distinct-type">distinct int</a> of type <tt class="docutils literal"><span class="pre"><span class="Identifier">BackwardsIndex</span></span></tt>, we can have a <tt class="docutils literal"><span class="pre"><span class="Identifier">lastIndex</span></span></tt> constant defined as <tt class="docutils literal"><span class="pre"><span class="Keyword">const</span> <span class="Identifier">lastIndex</span> <span class="Operator">=</span> <span class="Operator">^</span><span class="DecNumber">1</span></span></tt>, and later used as <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span><span class="Punctuation">[</span><span class="DecNumber">0</span> <span class="Operator">..</span> <span class="Identifier">lastIndex</span><span class="Punctuation">]</span></span></tt>.</p>

<h2><a class="toc-backref" id="advanced-types-objects" href="#advanced-types-objects">Objects</a></h2><p>The default type to pack different values together in a single structure with a name is the object type. An object is a value type, which means that when an object is assigned to a new variable all its components are copied as well.</p>
<p>Each object type <tt class="docutils literal"><span class="pre"><span class="Identifier">Foo</span></span></tt> has a constructor <tt class="docutils literal"><span class="pre"><span class="Identifier">Foo</span><span class="Punctuation">(</span><span class="Identifier">field</span><span class="Punctuation">:</span> <span class="Identifier">value</span><span class="Punctuation">,</span> <span class="Operator">...</span><span class="Punctuation">)</span></span></tt> where all of its fields can be initialized. Unspecified fields will get their default value.</p>
<p><pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">var</span> <span class="Identifier">person1</span> <span class="Operator">=</span> <span class="Identifier">Person</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">30</span><span class="Punctuation">)</span>

<span class="Identifier">echo</span> <span class="Identifier">person1</span><span class="Operator">.</span><span class="Identifier">name</span> <span class="Comment"># &quot;Peter&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">person1</span><span class="Operator">.</span><span class="Identifier">age</span>  <span class="Comment"># 30</span>

<span class="Keyword">var</span> <span class="Identifier">person2</span> <span class="Operator">=</span> <span class="Identifier">person1</span> <span class="Comment"># copy of person 1</span>

<span class="Identifier">person2</span><span class="Operator">.</span><span class="Identifier">age</span> <span class="Operator">+=</span> <span class="DecNumber">14</span>

<span class="Identifier">echo</span> <span class="Identifier">person1</span><span class="Operator">.</span><span class="Identifier">age</span> <span class="Comment"># 30</span>
<span class="Identifier">echo</span> <span class="Identifier">person2</span><span class="Operator">.</span><span class="Identifier">age</span> <span class="Comment"># 44</span>


<span class="Comment"># the order may be changed</span>
<span class="Keyword">let</span> <span class="Identifier">person3</span> <span class="Operator">=</span> <span class="Identifier">Person</span><span class="Punctuation">(</span><span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">12</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Quentin&quot;</span><span class="Punctuation">)</span>

<span class="Comment"># not every member needs to be specified</span>
<span class="Keyword">let</span> <span class="Identifier">person4</span> <span class="Operator">=</span> <span class="Identifier">Person</span><span class="Punctuation">(</span><span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">3</span><span class="Punctuation">)</span>
<span class="Comment"># unspecified members will be initialized with their default</span>
<span class="Comment"># values. In this case it is the empty string.</span>
<span class="Identifier">doAssert</span> <span class="Identifier">person4</span><span class="Operator">.</span><span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;&quot;</span></pre></p>
<p>Object fields that should be visible from outside the defining module have to be marked with <tt class="docutils literal"><span class="pre"><span class="Operator">*</span></span></tt>.</p>
<p><pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Person</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Comment"># the type is visible from other modules</span>
    <span class="Identifier">name</span><span class="Operator">*:</span> <span class="Identifier">string</span>  <span class="Comment"># the field of this type is visible from other modules</span>
    <span class="Identifier">age</span><span class="Operator">*:</span> <span class="Identifier">int</span></pre></p>

<h2><a class="toc-backref" id="advanced-types-tuples" href="#advanced-types-tuples">Tuples</a></h2><p>Tuples are very much like what you have seen so far from objects. They are value types where the assignment operator copies each component. Unlike object types though, tuple types are structurally typed, meaning different tuple-types are <em>equivalent</em> if they specify fields of the same type and of the same name in the same order.</p>
<p>The constructor <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> can be used to construct tuples. The order of the fields in the constructor must match the order in the tuple's definition. But unlike objects, a name for the tuple type may not be used here.</p>
<p>Like the object type the notation <tt class="docutils literal"><span class="pre"><span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">field</span></span></tt> is used to access a tuple's field. Another notation that is not available for objects is <tt class="docutils literal"><span class="pre"><span class="Identifier">t</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></span></tt> to access the <tt class="docutils literal"><span class="pre"><span class="Identifier">i</span></span></tt>'th field. Here <tt class="docutils literal"><span class="pre"><span class="Identifier">i</span></span></tt> must be a constant integer.</p>
<p><pre class="listing"><span class="Keyword">type</span>
  <span class="Comment"># type representing a person:</span>
  <span class="Comment"># A person consists of a name and an age.</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">tuple</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  
  <span class="Comment"># Alternative syntax for an equivalent type.</span>
  <span class="Identifier">PersonX</span> <span class="Operator">=</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
  
  <span class="Comment"># anonymous field syntax</span>
  <span class="Identifier">PersonY</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">person</span><span class="Punctuation">:</span> <span class="Identifier">Person</span>
  <span class="Identifier">personX</span><span class="Punctuation">:</span> <span class="Identifier">PersonX</span>
  <span class="Identifier">personY</span><span class="Punctuation">:</span> <span class="Identifier">PersonY</span>

<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">30</span><span class="Punctuation">)</span>
<span class="Comment"># Person and PersonX are equivalent</span>
<span class="Identifier">personX</span> <span class="Operator">=</span> <span class="Identifier">person</span>

<span class="Comment"># Create a tuple with anonymous fields:</span>
<span class="Identifier">personY</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">30</span><span class="Punctuation">)</span>

<span class="Comment"># A tuple with anonymous fields is compatible with a tuple that has</span>
<span class="Comment"># field names.</span>
<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Identifier">personY</span>
<span class="Identifier">personY</span> <span class="Operator">=</span> <span class="Identifier">person</span>

<span class="Comment"># Usually used for short tuple initialization syntax</span>
<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">30</span><span class="Punctuation">)</span>

<span class="Identifier">echo</span> <span class="Identifier">person</span><span class="Operator">.</span><span class="Identifier">name</span> <span class="Comment"># &quot;Peter&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">person</span><span class="Operator">.</span><span class="Identifier">age</span>  <span class="Comment"># 30</span>

<span class="Identifier">echo</span> <span class="Identifier">person</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Comment"># &quot;Peter&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">person</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Comment"># 30</span>

<span class="Comment"># You don't need to declare tuples in a separate type section.</span>
<span class="Keyword">var</span> <span class="Identifier">building</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">street</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">number</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
<span class="Identifier">building</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="StringLit">&quot;Rue del Percebe&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">13</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">building</span><span class="Operator">.</span><span class="Identifier">street</span>

<span class="Comment"># The following line does not compile, they are different tuples!</span>
<span class="Comment">#person = building</span>
<span class="Comment"># --&gt; Error: type mismatch: got (tuple[street: string, number: int])</span>
<span class="Comment">#     but expected 'Person'</span></pre></p>
<p>Even though you don't need to declare a type for a tuple to use it, tuples created with different field names will be considered different objects despite having the same field types.</p>
<p>Tuples can be <em>unpacked</em> during variable assignment. This can be handy to assign directly the fields of the tuples to individually named variables. An example of this is the <a class="reference external" href="os.html#splitFile,string">splitFile</a> proc from the <a class="reference external" href="os.html">os module</a> which returns the directory, name, and extension of a path at the same time. For tuple unpacking to work you must use parentheses around the values you want to assign the unpacking to, otherwise, you will be assigning the same value to all the individual variables! For example:</p>
<p><pre class="listing"><span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">os</span>

<span class="Keyword">let</span>
  <span class="Identifier">path</span> <span class="Operator">=</span> <span class="StringLit">&quot;usr/local/nimc.html&quot;</span>
  <span class="Punctuation">(</span><span class="Identifier">dir</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="Identifier">ext</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">splitFile</span><span class="Punctuation">(</span><span class="Identifier">path</span><span class="Punctuation">)</span>
  <span class="Identifier">baddir</span><span class="Punctuation">,</span> <span class="Identifier">badname</span><span class="Punctuation">,</span> <span class="Identifier">badext</span> <span class="Operator">=</span> <span class="Identifier">splitFile</span><span class="Punctuation">(</span><span class="Identifier">path</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">dir</span>      <span class="Comment"># outputs &quot;usr/local&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">name</span>     <span class="Comment"># outputs &quot;nimc&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">ext</span>      <span class="Comment"># outputs &quot;.html&quot;</span>
<span class="Comment"># All the following output the same line:</span>
<span class="Comment"># &quot;(dir: usr/local, name: nimc, ext: .html)&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">baddir</span>
<span class="Identifier">echo</span> <span class="Identifier">badname</span>
<span class="Identifier">echo</span> <span class="Identifier">badext</span></pre></p>
<p>Tuple unpacking is also supported in for-loops:</p>
<p><pre class="listing"><span class="Keyword">let</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="Punctuation">(</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="CharLit">'a'</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="DecNumber">20</span><span class="Punctuation">,</span> <span class="CharLit">'b'</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="DecNumber">30</span><span class="Punctuation">,</span> <span class="CharLit">'c'</span><span class="Punctuation">)</span><span class="Punctuation">]</span>

<span class="Keyword">for</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">)</span> <span class="Keyword">in</span> <span class="Identifier">a</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">x</span>
<span class="Comment"># This will output: 10; 20; 30</span>

<span class="Comment"># Accessing the index is also possible:</span>
<span class="Keyword">for</span> <span class="Identifier">i</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">)</span> <span class="Keyword">in</span> <span class="Identifier">a</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span><span class="Punctuation">,</span> <span class="Identifier">c</span>
<span class="Comment"># This will output: 0a; 1b; 2c</span></pre></p>
<p>Fields of tuples are always public, they don't need to be explicitly marked to be exported, unlike for example fields in an object type.</p>

<h2><a class="toc-backref" id="advanced-types-reference-and-pointer-types" href="#advanced-types-reference-and-pointer-types">Reference and pointer types</a></h2><p>References (similar to pointers in other programming languages) are a way to introduce many-to-one relationships. This means different references can point to and modify the same location in memory.</p>
<p>Nim distinguishes between <span id="traced_1">traced</span> and <span id="untraced_1">untraced</span> references. Untraced references are also called <em>pointers</em>. Traced references point to objects in a garbage-collected heap, untraced references point to manually allocated objects or objects elsewhere in memory. Thus, untraced references are <em>unsafe</em>. However, for certain low-level operations (e.g. accessing the hardware), untraced references are necessary.</p>
<p>Traced references are declared with the <strong>ref</strong> keyword; untraced references are declared with the <strong>ptr</strong> keyword.</p>
<p>The empty <tt class="docutils literal"><span class="pre"><span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt> subscript notation can be used to <em>de-refer</em> a reference, meaning to retrieve the item the reference points to. The <tt class="docutils literal"><span class="pre"><span class="Operator">.</span></span></tt> (access a tuple/object field operator) and <tt class="docutils literal"><span class="pre"><span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt> (array/string/sequence index operator) operators perform implicit dereferencing operations for reference types:</p>
<p><pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">var</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">data</span><span class="Punctuation">:</span> <span class="DecNumber">9</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span>
<span class="Comment"># no need to write n[].data; in fact n[].data is highly discouraged!</span></pre></p>
<p>To allocate a new traced object, the built-in procedure <tt class="docutils literal"><span class="pre"><span class="Identifier">new</span></span></tt> can be used:</p>
<p><pre class="listing"><span class="Keyword">var</span> <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
<span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">)</span></pre></p>
<p>To deal with untraced memory, the procedures <tt class="docutils literal"><span class="pre"><span class="Identifier">alloc</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">dealloc</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">realloc</span></span></tt> can be used. The <a class="reference external" href="system.html">system</a> module's documentation contains further details.</p>
<p>If a reference points to <em>nothing</em>, it has the value <tt class="docutils literal"><span class="pre"><span class="Keyword">nil</span></span></tt>.</p>

<h2><a class="toc-backref" id="advanced-types-procedural-type" href="#advanced-types-procedural-type">Procedural type</a></h2><p>A procedural type is a (somewhat abstract) pointer to a procedure. <tt class="docutils literal"><span class="pre"><span class="Keyword">nil</span></span></tt> is an allowed value for a variable of a procedural type. Nim uses procedural types to achieve <span id="functional_1">functional</span> programming techniques.</p>
<p>Example:</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">greet</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="StringLit">&quot;Hello, &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">name</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot;!&quot;</span>

<span class="Keyword">proc</span> <span class="Identifier">bye</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="StringLit">&quot;Goodbye, &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">name</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot;.&quot;</span>

<span class="Keyword">proc</span> <span class="Identifier">communicate</span><span class="Punctuation">(</span><span class="Identifier">greeting</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">greeting</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">)</span>

<span class="Identifier">communicate</span><span class="Punctuation">(</span><span class="Identifier">greet</span><span class="Punctuation">,</span> <span class="StringLit">&quot;John&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">communicate</span><span class="Punctuation">(</span><span class="Identifier">bye</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Mary&quot;</span><span class="Punctuation">)</span></pre></p>
<p>A subtle issue with procedural types is that the calling convention of the procedure influences the type compatibility: procedural types are only compatible if they have the same calling convention. The different calling conventions are listed in the <a class="reference external" href="manual.html#types-procedural-type">manual</a>.</p>

<h2><a class="toc-backref" id="advanced-types-distinct-type" href="#advanced-types-distinct-type">Distinct type</a></h2><p>A Distinct type allows for the creation of a new type that &quot;does not imply a subtype relationship between it and its base type&quot;. You must <strong>explicitly</strong> define all behavior for the distinct type. To help with this, both the distinct type and its base type can cast from one type to the other. Examples are provided in the <a class="reference external" href="manual.html#types-distinct-type">manual</a>.</p>

<h1><a class="toc-backref" id="modules" href="#modules">Modules</a></h1><p>Nim supports splitting a program into pieces with a <em>module</em> concept. Each module is in its own file. Modules enable <span id="information-hiding_1">information hiding</span> and <span id="separate-compilation_1">separate compilation</span>. A module may gain access to the symbols of another module by using the <span id="import_1">import</span> statement. Only top-level symbols that are marked with an asterisk (<tt class="docutils literal"><span class="pre"><span class="Operator">*</span></span></tt>) are exported:</p>
<p><pre class="listing"><span class="Comment"># Module A</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Operator">*</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Comment"># allocate a new sequence:</span>
  <span class="Identifier">newSeq</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Comment"># multiply two int sequences:</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">0</span> <span class="Operator">..&lt;</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">result</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">*</span> <span class="Identifier">b</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>

<span class="Keyword">when</span> <span class="Identifier">isMainModule</span><span class="Punctuation">:</span>
  <span class="Comment"># test the new `*` operator for sequences:</span>
  <span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span> <span class="Operator">*</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">9</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre></p>
<p>The above module exports <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Operator">*</span></span></tt>, but not <tt class="docutils literal"><span class="pre"><span class="Identifier">y</span></span></tt>.</p>
<p>A module's top-level statements are executed at the start of the program. This can be used to initialize complex data structures for example.</p>
<p>Each module has a special magic constant <tt class="docutils literal"><span class="pre"><span class="Identifier">isMainModule</span></span></tt> that is true if the module is compiled as the main file. This is very useful to embed tests within the module as shown by the above example.</p>
<p>A symbol of a module <em>can</em> be <em>qualified</em> with the <tt class="docutils literal"><span class="pre"><span class="Identifier">module</span><span class="Operator">.</span><span class="Identifier">symbol</span></span></tt> syntax. And if a symbol is ambiguous, it <em>must</em> be qualified. A symbol is ambiguous if it is defined in two (or more) different modules and both modules are imported by a third one:</p>
<p><pre class="listing"><span class="Comment"># Module A</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Operator">*:</span> <span class="Identifier">string</span></pre></p>
<p><pre class="listing"><span class="Comment"># Module B</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Operator">*:</span> <span class="Identifier">int</span></pre></p>
<p><pre class="listing"><span class="Comment"># Module C</span>
<span class="Keyword">import</span> <span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># error: x is ambiguous</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># okay: qualifier used</span>

<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">4</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># not ambiguous: uses the module C's x</span></pre></p>
<p>But this rule does not apply to procedures or iterators. Here the overloading rules apply:</p>
<p><pre class="listing"><span class="Comment"># Module A</span>
<span class="Keyword">proc</span> <span class="Identifier">x</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">a</span></pre></p>
<p><pre class="listing"><span class="Comment"># Module B</span>
<span class="Keyword">proc</span> <span class="Identifier">x</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">a</span></pre></p>
<p><pre class="listing"><span class="Comment"># Module C</span>
<span class="Keyword">import</span> <span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span><span class="Punctuation">)</span>   <span class="Comment"># no error: A.x is called</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">(</span><span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span>  <span class="Comment"># no error: B.x is called</span>

<span class="Keyword">proc</span> <span class="Identifier">x</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span><span class="Punctuation">)</span>   <span class="Comment"># ambiguous: which `x` is to call?</span></pre></p>

<h2><a class="toc-backref" id="modules-excluding-symbols" href="#modules-excluding-symbols">Excluding symbols</a></h2><p>The normal <tt class="docutils literal"><span class="pre"><span class="Keyword">import</span></span></tt> statement will bring in all exported symbols. These can be limited by naming symbols that should be excluded using the <tt class="docutils literal"><span class="pre"><span class="Keyword">except</span></span></tt> qualifier.</p>
<p><pre class="listing"><span class="Keyword">import</span> <span class="Identifier">mymodule</span> <span class="Keyword">except</span> <span class="Identifier">y</span></pre></p>

<h2><a class="toc-backref" id="modules-from-statement" href="#modules-from-statement">From statement</a></h2><p>We have already seen the simple <tt class="docutils literal"><span class="pre"><span class="Keyword">import</span></span></tt> statement that just imports all exported symbols. An alternative that only imports listed symbols is the <tt class="docutils literal"><span class="pre"><span class="Keyword">from</span> <span class="Keyword">import</span></span></tt> statement:</p>
<p><pre class="listing"><span class="Keyword">from</span> <span class="Identifier">mymodule</span> <span class="Keyword">import</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span></pre></p>
<p>The <tt class="docutils literal"><span class="pre"><span class="Keyword">from</span></span></tt> statement can also force namespace qualification on symbols, thereby making symbols available, but needing to be qualified in order to be used.</p>
<p><pre class="listing"><span class="Keyword">from</span> <span class="Identifier">mymodule</span> <span class="Keyword">import</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span>

<span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>           <span class="Comment"># use x without any qualification</span></pre></p>
<p><pre class="listing"><span class="Keyword">from</span> <span class="Identifier">mymodule</span> <span class="Keyword">import</span> <span class="Keyword">nil</span>

<span class="Identifier">mymodule</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>  <span class="Comment"># must qualify x with the module name as prefix</span>

<span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>           <span class="Comment"># using x here without qualification is a compile error</span></pre></p>
<p>Since module names are generally long to be descriptive, you can also define a shorter alias to use when qualifying symbols.</p>
<p><pre class="listing"><span class="Keyword">from</span> <span class="Identifier">mymodule</span> <span class="Keyword">as</span> <span class="Identifier">m</span> <span class="Keyword">import</span> <span class="Keyword">nil</span>

<span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>         <span class="Comment"># m is aliasing mymodule</span></pre></p>

<h2><a class="toc-backref" id="modules-include-statement" href="#modules-include-statement">Include statement</a></h2><p>The <tt class="docutils literal"><span class="pre"><span class="Keyword">include</span></span></tt> statement does something fundamentally different than importing a module: it merely includes the contents of a file. The <tt class="docutils literal"><span class="pre"><span class="Keyword">include</span></span></tt> statement is useful to split up a large module into several files:</p>
<p><pre class="listing"><span class="Keyword">include</span> <span class="Identifier">fileA</span><span class="Punctuation">,</span> <span class="Identifier">fileB</span><span class="Punctuation">,</span> <span class="Identifier">fileC</span></pre></p>

<h1><a class="toc-backref" id="part-2" href="#part-2">Part 2</a></h1><p>So, now that we are done with the basics, let's see what Nim offers apart from a nice syntax for procedural programming: <a class="reference external" href="tut2.html">Part II</a></p>
</p>
    
  </div>
</div>

      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br>
        <small style="color: var(--hint);">Made with Nim. Generated: 2024-10-23 19:01:12 UTC</small>
      </div>
    </div>
  </div>
      <script defer data-domain="nim-lang.org" src="https://plausible.io/js/plausible.js"></script>
    
</body>
</html>
