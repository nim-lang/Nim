version 0.9.2
=============

- implement the compiler as a service
- fix broken expr/stmt handling for proc bodies
- make 'bind' default for templates and introduce 'mixin'
- implicit deref for parameter matching; overloading based on 'var T'
- optimize genericAssign in the code generator


Bugs
----

- sneaking with qualifiedLookup() is really broken!
- bug: aporia.nim(968, 5) Error: ambiguous identifier: 'DELETE' -- 
  use a qualifier
- bug: the parser is not strict enough with newlines: 'echo "a" echo "b"' 
  compiles
- bug: blocks can "export" an identifier but the CCG generates {} for them ...
- bug: what if we pass an iterator to a proc var? iterators use tyProc too ...


version 0.9.XX
==============

- make:
  p(a, b): 
    echo a
    echo b
  
  the same as:
  
  p(a, b, proc() =
    echo a
    echo b)

- implement the "snoopResult" pragma
- implement "closure tuple consists of a single 'ref'" optimization
- implement for loop transformation for first class iterators
- JS gen:
  - fix exception handling
- object branch transitions can't work with the current 'reset'; add a 'reset'
  with an additional parameter
- fix remaining closure bugs:
  - test evals.nim with closures
  - what about macros with closures?

- allow implicit forward declarations of procs via a pragma (so that the
  wrappers can deactivate it)
- rethink the syntax: distinction between expr and stmt is unfortunate; 
  indentation handling is quite complex too; problem with exception handling
  is that often the scope of ``try`` is wrong and apart from that ``try`` is
  a full blown statement; a ``try`` expression might be a good idea to make
  error handling more light-weight
- ``=`` should be overloadable; requires specialization for ``=``
- fix destructors; don't work yet when used as expression
- make use of ``tyIter`` to fix the implicit items/pairs issue
- better support for macros that rewrite procs
- macros need access to types and symbols
- document nimdoc properly finally
- make 'clamp' a magic for the range stuff
- implement a warning message for shadowed 'result' variable
- we need to support iteration of 2 different data structures in parallel
- implement proper coroutines
- proc specialization in the code gen for write barrier specialization
- tlastmod returns wrong results on BSD (Linux, MacOS X: works)
- nested tuple unpacking; tuple unpacking in non-var-context
- test branch coverage
- make pegs support a compile-time option and make c2nim use regexes instead
  per default?
- 'const' objects including case objects
- 'export' feature
- from buggymodule import * except optBroken, optBroken2
- think about ``{:}.toTable[int, string]()``
- mocking support with ``tyProxy`` that does:
  o.p(x) --> p(o, x) -->  myMacro(p, o, x)
  
  This is really the opposite of ``tyExpr``:
  * For parameter ``tyExpr`` any argument matches.
  * Argument ``tyProxy`` matches any parameter.
  

Library
-------

- suffix trees
- locale support; i18n module
- bignums


Low priority
------------

- make 'raiseHook' take a closure and provide push and pop for this
  --> Lisp-style condition system
- change how comments are part of the AST
- ``with proc `+`(x, y: T): T`` for generic code
- new feature: ``distinct T with operations``
- implement the "easy" constructors idea
- resizing of strings/sequences could take into account the memory that
  is allocated
- timeout for locks
- compilation cache:
  - adapt thread var emulation to care about the new merge operation
  - check for interface changes; if only the implementation changes, no
    need to recompile clients; er ... what about templates, macros or anything
    that has inlining semantics?
- codegen should use "NIM_CAST" macro and respect aliasing rules for GCC
- GC: precise stack marking;
  escape analysis for string/seq seems to be easy to do too;
  even further write barrier specialization
- GC: marker procs Boehm GC
- implement marker procs for message passing
- optimize method dispatchers
- activate more thread tests
- implement ``--script:sh|bat`` command line option; think about script 
  generation
- implement closures that support nesting of *procs* > 1


Further optimization ideas
==========================

- To optimize further copies away, you want to gather the additional
  information inlining would provide, but don't inline for code size reasons.


Version 2 and beyond
====================

- shared memory heap: ``shared ref`` etc. The only hard part in the GC is to
  "stop the world". However, it may be worthwhile to generate explicit 
  (or implicit) syncGC() calls in loops. Automatic loop injection seems
  troublesome, but maybe we can come up with a simple heuristic. (All procs
  that `new` shared memory are syncGC() candidates...)

- implement/generalize the effect system; checked exceptions
- const ptr/ref

- language change: inheritance should only work with reference types, so that
  the ``type`` field is not needed for objects! --> zero overhead aggregation
  BETTER: ``of`` and safe object conversions only work with ref objects. Same
  for multi methods.
  
- explicit nil types?
  * nil seq[int]
  * nil string
  * nil ref int
  * nil ptr THallo
  * nil proc 

- better for backwards compatibility: default nilable, but ``not nil``
  notation:
  
  type
    PWindow = ref TWindow not nil
    
  The problem with ``nil`` is that the language currently relies on it for
  implicit initialization. Initialization is different from assignment. The
  issues can "easily" dealt with by ensuring:
  
    var x = myProc() # checks myProc() initializes every pointer explicitely

- guards for the 'case' statement; generalized case statement;
  a guard looks like: 
  
    case x
    of nkStmtList if x.value == 0: 
  
  a generalized case statement looks like:
    
    case x with `=~`

- implement ``partial`` pragma for partial evaluation: easily done with AST
  overloading
- ``hoist`` pragma for loop hoisting: can be easily done with 
  AST overloading + global

