<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="https://www.w3.org/1999/xhtml" xml:lang="en" lang="en" data-theme="auto">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Nim IDE Integration Guide</title>

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- CSS -->
<link rel="stylesheet" type="text/css" href="nimdoc.out.css?v=2.2.1">

<!-- JS -->
<script type="text/javascript" src="dochack.js?v=2.2.1"></script>
</head>
<body>
  <div class="document" id="documentId">
    <div class="container">
      <h1 class="title">Nim IDE Integration Guide</h1>
      <div class="row">
  <div class="three columns">
    <div class="theme-select-wrapper">
      <label for="theme-select">Theme:&nbsp;</label>
      <select id="theme-select" onchange="setTheme(this.value)">
        <option value="auto">ðŸŒ— Match OS</option>
        <option value="dark">ðŸŒ‘ Dark</option>
        <option value="light">ðŸŒ• Light</option>
      </select>
    </div>
    <div id="global-links">
      <ul class="simple-boot">
        <li><a href="manual.html">Manual</a></li>
        <li><a href="lib.html">Standard library</a></li>
        <li> <a id="indexLink" href="theindex.html">Index</a></li>
        <li><a href="compiler/theindex.html">Compiler docs</a></li>
        <li><a href="https://nim-lang.github.io/fusion/theindex.html">Fusion docs</a></li>
        <li><a href="https://nim-lang.github.io/Nim/">devel</a>, <a href="https://nim-lang.org/documentation.html">stable</a></li>
      </ul>
    </div>
    <div id="searchInputDiv">
      Search: <input type="search" id="searchInput"
        oninput="search()" />
    </div>
    <div class="search-groupby">
  Group by:
  <select onchange="groupBy(this.value)">
    <option value="section">Section</option>
    <option value="type">Type</option>
  </select>
</div>

    <ul class="simple simple-toc" id="toc-list">
  <li><a class="reference" id="idetools-invocation_toc" href="#idetools-invocation">Idetools invocation</a></li>
<ul class="simple"><li><a class="reference" id="idetools-invocation-specifying-the-location-of-the-query_toc" href="#idetools-invocation-specifying-the-location-of-the-query">Specifying the location of the query</a></li>
<li><a class="reference" id="idetools-invocation-definitions_toc" href="#idetools-invocation-definitions">Definitions</a></li>
<li><a class="reference" id="idetools-invocation-suggestions_toc" href="#idetools-invocation-suggestions">Suggestions</a></li>
<li><a class="reference" id="idetools-invocation-invocation-context_toc" href="#idetools-invocation-invocation-context">Invocation context</a></li>
<li><a class="reference" id="idetools-invocation-symbol-usages_toc" href="#idetools-invocation-symbol-usages">Symbol usages</a></li>
<li><a class="reference" id="idetools-invocation-expression-evaluation_toc" href="#idetools-invocation-expression-evaluation">Expression evaluation</a></li>
</ul><li><a class="reference" id="compiler-as-a-service-caas_toc" href="#compiler-as-a-service-caas">Compiler as a service (CAAS)</a></li>
<li><a class="reference" id="parsing-idetools-output_toc" href="#parsing-idetools-output">Parsing idetools output</a></li>
<ul class="simple"><li><a class="reference" id="parsing-idetools-output-skconst_toc" href="#parsing-idetools-output-skconst">skConst</a></li>
<li><a class="reference" id="parsing-idetools-output-skenumfield_toc" href="#parsing-idetools-output-skenumfield">skEnumField</a></li>
<li><a class="reference" id="parsing-idetools-output-skforvar_toc" href="#parsing-idetools-output-skforvar">skForVar</a></li>
<li><a class="reference" id="parsing-idetools-output-skiterator-skclosureiterator_toc" href="#parsing-idetools-output-skiterator-skclosureiterator">skIterator, skClosureIterator</a></li>
<li><a class="reference" id="parsing-idetools-output-sklabel_toc" href="#parsing-idetools-output-sklabel">skLabel</a></li>
<li><a class="reference" id="parsing-idetools-output-sklet_toc" href="#parsing-idetools-output-sklet">skLet</a></li>
<li><a class="reference" id="parsing-idetools-output-skmacro_toc" href="#parsing-idetools-output-skmacro">skMacro</a></li>
<li><a class="reference" id="parsing-idetools-output-skmethod_toc" href="#parsing-idetools-output-skmethod">skMethod</a></li>
<li><a class="reference" id="parsing-idetools-output-skparam_toc" href="#parsing-idetools-output-skparam">skParam</a></li>
<li><a class="reference" id="parsing-idetools-output-skproc_toc" href="#parsing-idetools-output-skproc">skProc</a></li>
<li><a class="reference" id="parsing-idetools-output-skresult_toc" href="#parsing-idetools-output-skresult">skResult</a></li>
<li><a class="reference" id="parsing-idetools-output-sktemplate_toc" href="#parsing-idetools-output-sktemplate">skTemplate</a></li>
<li><a class="reference" id="parsing-idetools-output-sktype_toc" href="#parsing-idetools-output-sktype">skType</a></li>
<li><a class="reference" id="parsing-idetools-output-skvar_toc" href="#parsing-idetools-output-skvar">skVar</a></li>
</ul><li><a class="reference" id="test-suite_toc" href="#test-suite">Test suite</a></li>
<ul class="simple"><li><a class="reference" id="test-suite-running-the-test-suite_toc" href="#test-suite-running-the-test-suite">Running the test suite</a></li>
<li><a class="reference" id="test-suite-test-case-file-format_toc" href="#test-suite-test-case-file-format">Test case file format</a></li>
</ul>
</ul>

  </div>
  <div class="nine columns" id="content">
    <a href="https://github.com/nim-lang/Nim/tree/devel/doc/idetools.md#L1" class="link-seesrc" target="_blank">Source</a>&nbsp;&nbsp;
<a href="https://github.com/nim-lang/Nim/edit/devel/doc/idetools.md#L1" class="link-seesrc" target="_blank" >Edit</a>&nbsp;&nbsp;

    <div id="tocRoot"></div>
    
    <p class="module-desc"><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">Author:</th><td>Britney Spears</td></tr>
<tr><th class="docinfo-name">Version:</th><td>2.2.1</td></tr>
</tbody></table><blockquote class="markdown-quote"><p>&quot;yes, I'm the creator&quot; -- Araq, 2013-07-26 19:28:32.</p></blockquote>
<p>Note: this is mostly outdated, see instead <a class="reference external" href="nimsuggest.html">nimsuggest</a></p>
<p>Nim differs from many other compilers in that it is really fast, and being so fast makes it suited to provide external queries for text editors about the source code being written. Through the <tt class="docutils literal"><span class="pre">idetools</span></tt> command of <a class="reference external" href="nimc.html">the compiler</a>, any IDE can query a <tt class="docutils literal"><span class="pre">.nim</span></tt> source file and obtain useful information like definition of symbols or suggestions for completion.</p>
<p>This document will guide you through the available options. If you want to look at practical examples of idetools support you can look at the test files found in the <a class="reference internal" href="#test-suite">Test suite</a> or <a class="reference external" href="https://github.com/Araq/Nim/wiki/Editor-Support">various editor integrations</a> already available.</p>

<h1><a class="toc-backref" id="idetools-invocation" href="#idetools-invocation">Idetools invocation</a></h1>
<h2><a class="toc-backref" id="idetools-invocation-specifying-the-location-of-the-query" href="#idetools-invocation-specifying-the-location-of-the-query">Specifying the location of the query</a></h2><p>All of the available idetools commands require you to specify a query location through the <tt class="docutils literal"><span class="pre">--track</span></tt> or <tt class="docutils literal"><span class="pre">--trackDirty</span></tt> switches. The general idetools invocations are:</p>
<p><pre class="listing"><span class="program">nim</span> <span class="option">idetools</span> <span class="option">--track:FILE,LINE,COL</span> <span class="option">&lt;switches&gt;</span> <span class="Identifier">proj.nim</span></pre></p>
<p>Or:</p>
<p><pre class="listing"><span class="program">nim</span> <span class="option">idetools</span> <span class="option">--trackDirty:DIRTY_FILE,FILE,LINE,COL</span> <span class="option">&lt;switches&gt;</span> <span class="Identifier">proj.nim</span></pre></p>
<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">proj.nim</span></tt></dt>
<dd>This is the main <em>project</em> filename. Most of the time you will pass in the same as <strong>FILE</strong>, but for bigger projects this is the file which is used as main entry point for the program, the one which users compile to generate a final binary.</dd>
<dt><tt class="docutils literal"><span class="pre">&lt;switches&gt;</span></tt></dt>
<dd>This would be any of the other idetools available options, like <tt class="docutils literal"><span class="pre">--def</span></tt> or <tt class="docutils literal"><span class="pre">--suggest</span></tt> explained in the following sections.</dd>
<dt><tt class="docutils literal"><span class="pre">COL</span></tt></dt>
<dd>An integer with the column you are going to query. For the compiler columns start at zero, so the first column will be <strong>0</strong> and the last in an 80 column terminal will be <strong>79</strong>.</dd>
<dt><tt class="docutils literal"><span class="pre">LINE</span></tt></dt>
<dd>An integer with the line you are going to query. For the compiler lines start at <strong>1</strong>.</dd>
<dt><tt class="docutils literal"><span class="pre">FILE</span></tt></dt>
<dd>The file you want to perform the query on. Usually you will pass in the same value as <strong>proj.nim</strong>.</dd>
<dt><tt class="docutils literal"><span class="pre">DIRTY_FILE</span></tt></dt>
<dd><p>The <strong>FILE</strong> parameter is enough for static analysis, but IDEs tend to have <em>unsaved buffers</em> where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the <tt class="docutils literal"><span class="pre">--trackDirty</span></tt> switch.</p>
<p>Dirty files are likely to contain errors and they are usually compiled partially only to the point needed to service the idetool request. The compiler discriminates them to ensure that <strong>a)</strong> they won't be cached and <strong>b)</strong> they won't invalidate the cached contents of the original module.</p>
<p>The other reason is that the dirty file can appear anywhere on disk (e.g. in tmpfs), but it must be treated as having a path matching the original module when it comes to usage of relative paths, etc. Queries, however, will refer to the dirty module name in their answers instead of the normal filename.</p>
</dd>
</dl>

<h2><a class="toc-backref" id="idetools-invocation-definitions" href="#idetools-invocation-definitions">Definitions</a></h2><p>The <tt class="docutils literal"><span class="pre">--def</span></tt> idetools switch performs a query about the definition of a specific symbol. If available, idetools will answer with the type, source file, line/column information and other accessory data if available like a docstring. With this information an IDE can provide the typical <em>Jump to definition</em> where a user puts the cursor on a symbol or uses the mouse to select it and is redirected to the place where the symbol is located.</p>
<p>Since Nim is implemented in Nim, one of the nice things of this feature is that any user with an IDE supporting it can quickly jump around the standard library implementation and see exactly what a proc does, learning about the language and seeing real life examples of how to write/implement specific features.</p>
<p>Idetools will always answer with a single definition or none if it can't find any valid symbol matching the position of the query.</p>

<h2><a class="toc-backref" id="idetools-invocation-suggestions" href="#idetools-invocation-suggestions">Suggestions</a></h2><p>The <tt class="docutils literal"><span class="pre">--suggest</span></tt> idetools switch performs a query about possible completion symbols at some point in the file. IDEs can easily provide an autocompletion feature where the IDE scans the current file (and related ones, if it knows about the language being edited and follows includes/imports) and when the user starts typing something a completion box with different options appears.</p>
<p>However such features are not context sensitive and work simply on string matching, which can be problematic in Nim especially due to the case insensitiveness of the language (plus underscores as separators!).</p>
<p>The typical usage scenario for this option is to call it after the user has typed the dot character for <a class="reference external" href="tut2.html#object-oriented-programming-method-call-syntax">the object oriented call syntax</a>. Idetools will try to return the suggestions sorted first by scope (from innermost to outermost) and then by item name.</p>

<h2><a class="toc-backref" id="idetools-invocation-invocation-context" href="#idetools-invocation-invocation-context">Invocation context</a></h2><p>The <tt class="docutils literal"><span class="pre">--context</span></tt> idetools switch is very similar to the suggestions switch, but instead of being used after the user has typed a dot character, this one is meant to be used after the user has typed an opening brace to start typing parameters.</p>

<h2><a class="toc-backref" id="idetools-invocation-symbol-usages" href="#idetools-invocation-symbol-usages">Symbol usages</a></h2><p>The <tt class="docutils literal"><span class="pre">--usages</span></tt> idetools switch lists all usages of the symbol at a position. IDEs can use this to find all the places in the file where the symbol is used and offer the user to rename it in all places at the same time. Again, a pure string based search and replace may catch symbols out of the scope of a function/loop.</p>
<p>For this kind of query the IDE will most likely ignore all the type/signature info provided by idetools and concentrate on the filename, line and column position of the multiple returned answers.</p>

<h2><a class="toc-backref" id="idetools-invocation-expression-evaluation" href="#idetools-invocation-expression-evaluation">Expression evaluation</a></h2><p>This feature is still under development. In the future it will allow an IDE to evaluate an expression in the context of the currently running/debugged user project.</p>

<h1><a class="toc-backref" id="compiler-as-a-service-caas" href="#compiler-as-a-service-caas">Compiler as a service (CAAS)</a></h1><p>The occasional use of idetools is acceptable for things like definitions, where the user puts the cursor on a symbol or double clicks it and after a second or two the IDE displays where that symbol is defined. Such latencies would be terrible for features like symbol suggestion, plus why wait at all if we can avoid it?</p>
<p>The idetools command can be run as a compiler service (CAAS), where you first launch the compiler and it will stay online as a server, accepting queries in a telnet like fashion. The advantage of staying on is that for many queries the compiler can cache the results of the compilation, and subsequent queries should be fast in the millisecond range, thus being responsive enough for IDEs.</p>
<p>If you want to start the server using stdin/stdout as communication you need to type:</p>
<p><pre class="listing"><span class="program">nim</span> <span class="option">serve</span> <span class="Identifier">--server.type:stdin</span> <span class="Identifier">proj.nim</span></pre></p>
<p>If you want to start the server using tcp and a port, you need to type:</p>
<p><pre class="listing"><span class="program">nim</span> <span class="option">serve</span> <span class="Identifier">--server.type:tcp</span> <span class="Identifier">--server.port:6000</span> <span class="Identifier">\</span>
    <span class="program">--server.address:hostname</span> <span class="Identifier">proj.nim</span></pre></p>
<p>In both cases the server will start up and await further commands. The syntax of the commands you can now send to the server is practically the same as running the nim compiler on the commandline, you only need to remove the name of the compiler since you are already talking to it. The server will answer with as many lines of text it thinks necessary plus an empty line to indicate the end of the answer.</p>
<p>You can find examples of client/server communication in the idetools tests found in the <a class="reference internal" href="#test-suite">Test suite</a>.</p>

<h1><a class="toc-backref" id="parsing-idetools-output" href="#parsing-idetools-output">Parsing idetools output</a></h1><p>Idetools outputs is always returned on single lines separated by tab characters (<tt class="docutils literal"><span class="pre">\t</span></tt>). The values of each column are:</p>
<ol class="simple"><li>Three characters indicating the type of returned answer (e.g. def for definition, <tt class="docutils literal"><span class="pre">sug</span></tt> for suggestion, etc).</li>
<li>Type of the symbol. This can be <tt class="docutils literal"><span class="pre">skProc</span></tt>, <tt class="docutils literal"><span class="pre">skLet</span></tt>, and just about any of the enums defined in the module <tt class="docutils literal"><span class="pre">compiler/ast.nim</span></tt>.</li>
<li>Full qualified path of the symbol. If you are querying a symbol defined in the <tt class="docutils literal"><span class="pre">proj.nim</span></tt> file, this would have the form <tt class="docutils literal"><span class="pre">proj.symbolName</span></tt>.</li>
<li>Type/signature. For variables and enums this will contain the type of the symbol, for procs, methods and templates this will contain the full unique signature (e.g. <tt class="docutils literal"><span class="pre">proc (File)</span></tt>).</li>
<li>Full path to the file containing the symbol.</li>
<li>Line where the symbol is located in the file. Lines start to count at <strong>1</strong>.</li>
<li>Column where the symbol is located in the file. Columns start to count at <strong>0</strong>.</li>
<li><p>Docstring for the symbol if available or the empty string. To differentiate the docstring from end of answer in server mode, the docstring is always provided enclosed in double quotes, and if the docstring spans multiple lines, all following lines of the docstring will start with a blank space to align visually with the starting quote.</p>
<p>Also, you won't find raw <tt class="docutils literal"><span class="pre">\n</span></tt> characters breaking the one answer per line format. Instead you will need to parse sequences in the form <tt class="docutils literal"><span class="pre">\xHH</span></tt>, where <em>HH</em> is a hexadecimal value (e.g. newlines generate the sequence <tt class="docutils literal"><span class="pre">\x0A</span></tt>).</p>
</li>
</ol>
<p>The following sections define the expected output for each kind of symbol for which idetools returns valid output.</p>

<h2><a class="toc-backref" id="parsing-idetools-output-skconst" href="#parsing-idetools-output-skconst">skConst</a></h2><p><strong>Third column</strong>: module + [n scope nesting] + const name.<br/><strong>Fourth column</strong>: the type of the const value.<br/><p><strong>Docstring</strong>: always the empty string.</p>
<p><pre class="listing"><span class="Keyword">const</span> <span class="Identifier">SOME_SEQUENCE</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">]</span>
<span class="Operator">--&gt;</span> <span class="Identifier">col</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Operator">$</span><span class="Identifier">MODULE</span><span class="Operator">.</span><span class="Identifier">SOME_SEQUENCE</span>
    <span class="Identifier">col</span> <span class="DecNumber">3</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span>
    <span class="Identifier">col</span> <span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&quot;</span></pre></p>
<br/></p>
<h2><a class="toc-backref" id="parsing-idetools-output-skenumfield" href="#parsing-idetools-output-skenumfield">skEnumField</a></h2><p><strong>Third column</strong>: module + [n scope nesting] + enum type + enum field name.<br/><strong>Fourth column</strong>: enum type grouping other enum fields.<br/><p><strong>Docstring</strong>: always the empty string.</p>
<p><pre class="listing"><span class="Identifier">Open</span><span class="Punctuation">(</span><span class="Identifier">filename</span><span class="Punctuation">,</span> <span class="Identifier">fmWrite</span><span class="Punctuation">)</span>
<span class="Operator">--&gt;</span> <span class="Identifier">col</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">FileMode</span><span class="Operator">.</span><span class="Identifier">fmWrite</span>
    <span class="Identifier">col</span> <span class="DecNumber">3</span><span class="Punctuation">:</span> <span class="Identifier">FileMode</span>
    <span class="Identifier">col</span> <span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&quot;</span></pre></p>
<br/></p>
<h2><a class="toc-backref" id="parsing-idetools-output-skforvar" href="#parsing-idetools-output-skforvar">skForVar</a></h2><p><strong>Third column</strong>: module + [n scope nesting] + var name.<br/><strong>Fourth column</strong>: type of the var.<br/><p><strong>Docstring</strong>: always the empty string.</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">looper</span><span class="Punctuation">(</span><span class="Identifier">filename</span> <span class="Operator">=</span> <span class="StringLit">&quot;tests.nim&quot;</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">letter</span> <span class="Keyword">in</span> <span class="Identifier">filename</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="Identifier">letter</span>
<span class="Operator">--&gt;</span> <span class="Identifier">col</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Operator">$</span><span class="Identifier">MODULE</span><span class="Operator">.</span><span class="Identifier">looper</span><span class="Operator">.</span><span class="Identifier">letter</span>
    <span class="Identifier">col</span> <span class="DecNumber">3</span><span class="Punctuation">:</span> <span class="Identifier">char</span>
    <span class="Identifier">col</span> <span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&quot;</span></pre></p>
<br/></p>
<h2><a class="toc-backref" id="parsing-idetools-output-skiterator-skclosureiterator" href="#parsing-idetools-output-skiterator-skclosureiterator">skIterator, skClosureIterator</a></h2><p>The fourth column will be the empty string if the iterator is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the iterator.</p>
<p><strong>Third column</strong>: module + [n scope nesting] + iterator name.<br/><strong>Fourth column</strong>: signature of the iterator including return type.<br/><p><strong>Docstring</strong>: docstring if available.</p>
<p><pre class="listing"><span class="Keyword">let</span>
  <span class="Identifier">text</span> <span class="Operator">=</span> <span class="StringLit">&quot;some text&quot;</span>
  <span class="Identifier">letters</span> <span class="Operator">=</span> <span class="Identifier">toSeq</span><span class="Punctuation">(</span><span class="Identifier">runes</span><span class="Punctuation">(</span><span class="Identifier">text</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Operator">--&gt;</span> <span class="Identifier">col</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Identifier">unicode</span><span class="Operator">.</span><span class="Identifier">runes</span>
    <span class="Identifier">col</span> <span class="DecNumber">3</span><span class="Punctuation">:</span> <span class="Keyword">iterator</span> <span class="Punctuation">(</span><span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Rune</span>
    <span class="Identifier">col</span> <span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="StringLit">&quot;iterates over any unicode character of the string `s`.&quot;</span></pre></p>
<br/></p>
<h2><a class="toc-backref" id="parsing-idetools-output-sklabel" href="#parsing-idetools-output-sklabel">skLabel</a></h2><p><strong>Third column</strong>: module + [n scope nesting] + name.<br/><strong>Fourth column</strong>: always the empty string.<br/><p><strong>Docstring</strong>: always the empty string.</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">test</span><span class="Punctuation">(</span><span class="Identifier">text</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">found</span> <span class="Operator">=</span> <span class="Operator">-</span><span class="DecNumber">1</span>
  <span class="Keyword">block</span> <span class="Identifier">loops</span><span class="Punctuation">:</span>
<span class="Operator">--&gt;</span> <span class="Identifier">col</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Operator">$</span><span class="Identifier">MODULE</span><span class="Operator">.</span><span class="Identifier">test</span><span class="Operator">.</span><span class="Identifier">loops</span>
    <span class="Identifier">col</span> <span class="DecNumber">3</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&quot;</span>
    <span class="Identifier">col</span> <span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&quot;</span></pre></p>
<br/></p>
<h2><a class="toc-backref" id="parsing-idetools-output-sklet" href="#parsing-idetools-output-sklet">skLet</a></h2><p><strong>Third column</strong>: module + [n scope nesting] + let name.<br/><strong>Fourth column</strong>: the type of the let variable.<br/><p><strong>Docstring</strong>: always the empty string.</p>
<p><pre class="listing"><span class="Keyword">let</span>
  <span class="Identifier">text</span> <span class="Operator">=</span> <span class="StringLit">&quot;some text&quot;</span>
<span class="Operator">--&gt;</span> <span class="Identifier">col</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Operator">$</span><span class="Identifier">MODULE</span><span class="Operator">.</span><span class="Identifier">text</span>
    <span class="Identifier">col</span> <span class="DecNumber">3</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Identifier">col</span> <span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&quot;</span></pre></p>
<br/></p>
<h2><a class="toc-backref" id="parsing-idetools-output-skmacro" href="#parsing-idetools-output-skmacro">skMacro</a></h2><p>The fourth column will be the empty string if the macro is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the macro.</p>
<p><strong>Third column</strong>: module + [n scope nesting] + macro name.<br/><strong>Fourth column</strong>: signature of the macro including return type.<br/><p><strong>Docstring</strong>: docstring if available.</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">testMacro</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">expect</span><span class="Punctuation">(</span><span class="Identifier">EArithmetic</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
<span class="Operator">--&gt;</span> <span class="Identifier">col</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Identifier">idetools_api</span><span class="Operator">.</span><span class="Identifier">expect</span>
    <span class="Identifier">col</span> <span class="DecNumber">3</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">expr</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">stmt</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span>
    <span class="Identifier">col</span> <span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&quot;</span></pre></p>
<br/></p>
<h2><a class="toc-backref" id="parsing-idetools-output-skmethod" href="#parsing-idetools-output-skmethod">skMethod</a></h2><p>The fourth column will be the empty string if the method is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the method.</p>
<p>Methods imply <a class="reference external" href=" tut2.html#object-oriented-programming-dynamic-dispatch">dynamic dispatch</a> and idetools performs a static analysis on the code. For this reason idetools may not return the definition of the correct method you are querying because it may be impossible to know until the code is executed. It will try to return the method which covers the most possible cases (i.e. for variations of different classes in a hierarchy it will prefer methods using the base class).</p>
<p>While at the language level a method is differentiated from others by the parameters and return value, the signature of the method returned by idetools returns also the pragmas for the method.</p>
<p>Note that at the moment the word <tt class="docutils literal"><span class="pre">proc</span></tt> is returned for the signature of the found method instead of the expected <tt class="docutils literal"><span class="pre">method</span></tt>. This may change in the future.</p>
<p><strong>Third column</strong>: module + [n scope nesting] + method name.<br/><strong>Fourth column</strong>: signature of the method including return type.<br/><p><strong>Docstring</strong>: docstring if available.</p>
<p><pre class="listing"><span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">PExpr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">quit</span> <span class="StringLit">&quot;to override!&quot;</span>
<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">PLiteral</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">x</span>
<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">PPlusExpr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">b</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Operator">--&gt;</span> <span class="Identifier">col</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Operator">$</span><span class="Identifier">MODULE</span><span class="Operator">.</span><span class="Identifier">eval</span>
    <span class="Identifier">col</span> <span class="DecNumber">3</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">PPlusExpr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">col</span> <span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&quot;</span></pre></p>
<br/></p>
<h2><a class="toc-backref" id="parsing-idetools-output-skparam" href="#parsing-idetools-output-skparam">skParam</a></h2><p><strong>Third column</strong>: module + [n scope nesting] + param name.<br/><strong>Fourth column</strong>: the type of the parameter.<br/><p><strong>Docstring</strong>: always the empty string.</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">reader</span><span class="Punctuation">(</span><span class="Identifier">filename</span> <span class="Operator">=</span> <span class="StringLit">&quot;tests.nim&quot;</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">let</span> <span class="Identifier">text</span> <span class="Operator">=</span> <span class="Identifier">readFile</span><span class="Punctuation">(</span><span class="Identifier">filename</span><span class="Punctuation">)</span>
<span class="Operator">--&gt;</span> <span class="Identifier">col</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Operator">$</span><span class="Identifier">MODULE</span><span class="Operator">.</span><span class="Identifier">reader</span><span class="Operator">.</span><span class="Identifier">filename</span>
    <span class="Identifier">col</span> <span class="DecNumber">3</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Identifier">col</span> <span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&quot;</span></pre></p>
<br/></p>
<h2><a class="toc-backref" id="parsing-idetools-output-skproc" href="#parsing-idetools-output-skproc">skProc</a></h2><p>The fourth column will be the empty string if the proc is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the proc.</p>
<p>While at the language level a proc is differentiated from others by the parameters and return value, the signature of the proc returned by idetools returns also the pragmas for the proc.</p>
<p><strong>Third column</strong>: module + [n scope nesting] + proc name.<br/><strong>Fourth column</strong>: signature of the proc including return type.<br/><p><strong>Docstring</strong>: docstring if available.</p>
<p><pre class="listing"><span class="Identifier">open</span><span class="Punctuation">(</span><span class="Identifier">filename</span><span class="Punctuation">,</span> <span class="Identifier">fmWrite</span><span class="Punctuation">)</span>
<span class="Operator">--&gt;</span> <span class="Identifier">col</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">Open</span>
    <span class="Identifier">col</span> <span class="DecNumber">3</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Keyword">var</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">FileMode</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span>
    <span class="Identifier">col</span> <span class="DecNumber">7</span><span class="Punctuation">:</span>
<span class="StringLit">&quot;Opens a file named `filename` with given `mode`.</span>
 
 <span class="Identifier">Default</span> <span class="Identifier">mode</span> <span class="Keyword">is</span> <span class="Identifier">readonly</span><span class="Operator">.</span> <span class="Identifier">Returns</span> <span class="Identifier">true</span> <span class="Identifier">iff</span> <span class="Identifier">the</span> <span class="Identifier">file</span> <span class="Identifier">could</span> <span class="Identifier">be</span> <span class="Identifier">opened</span><span class="Operator">.</span>
 <span class="Identifier">This</span> <span class="Identifier">throws</span> <span class="Identifier">no</span> <span class="Identifier">exception</span> <span class="Keyword">if</span> <span class="Identifier">the</span> <span class="Identifier">file</span> <span class="Identifier">could</span> <span class="Keyword">not</span> <span class="Identifier">be</span> <span class="Identifier">opened</span><span class="Operator">.</span><span class="StringLit">&quot;</span></pre></p>
<br/></p>
<h2><a class="toc-backref" id="parsing-idetools-output-skresult" href="#parsing-idetools-output-skresult">skResult</a></h2><p><strong>Third column</strong>: module + [n scope nesting] + result.<br/><strong>Fourth column</strong>: the type of the result.<br/><p><strong>Docstring</strong>: always the empty string.</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">getRandomValue</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">return</span> <span class="DecNumber">4</span>
<span class="Operator">--&gt;</span> <span class="Identifier">col</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Operator">$</span><span class="Identifier">MODULE</span><span class="Operator">.</span><span class="Identifier">getRandomValue</span><span class="Operator">.</span><span class="Identifier">result</span>
    <span class="Identifier">col</span> <span class="DecNumber">3</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">col</span> <span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&quot;</span></pre></p>
<br/></p>
<h2><a class="toc-backref" id="parsing-idetools-output-sktemplate" href="#parsing-idetools-output-sktemplate">skTemplate</a></h2><p>The fourth column will be the empty string if the template is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the template.</p>
<p><strong>Third column</strong>: module + [n scope nesting] + template name.<br/><strong>Fourth column</strong>: signature of the template including return type.<br/><p><strong>Docstring</strong>: docstring if available.</p>
<p><pre class="listing">  <span class="Keyword">let</span>
    <span class="Identifier">text</span> <span class="Operator">=</span> <span class="StringLit">&quot;some text&quot;</span>
    <span class="Identifier">letters</span> <span class="Operator">=</span> <span class="Identifier">toSeq</span><span class="Punctuation">(</span><span class="Identifier">runes</span><span class="Punctuation">(</span><span class="Identifier">text</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Operator">--&gt;</span> <span class="Identifier">col</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Identifier">sequtils</span><span class="Operator">.</span><span class="Identifier">toSeq</span>
      <span class="Identifier">col</span> <span class="DecNumber">3</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">expr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span>
      <span class="Identifier">col</span> <span class="DecNumber">7</span><span class="Punctuation">:</span>
  <span class="StringLit">&quot;Transforms any iterator into a sequence.</span>
   
   <span class="Identifier">Example</span><span class="Punctuation">:</span>
     
     <span class="Punctuation">`</span><span class="Punctuation">`</span><span class="Punctuation">`</span><span class="Identifier">nim</span>
     <span class="Keyword">let</span>
       <span class="Identifier">numeric</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">,</span> <span class="DecNumber">7</span><span class="Punctuation">,</span> <span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">9</span><span class="Punctuation">]</span>
       <span class="Identifier">odd_numbers</span> <span class="Operator">=</span> <span class="Identifier">toSeq</span><span class="Punctuation">(</span><span class="Identifier">filter</span><span class="Punctuation">(</span><span class="Identifier">numeric</span><span class="Punctuation">)</span> <span class="Keyword">do</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Identifier">bool</span><span class="Punctuation">:</span>
         <span class="Keyword">if</span> <span class="Identifier">x</span> <span class="Keyword">mod</span> <span class="DecNumber">2</span> <span class="Operator">==</span> <span class="DecNumber">1</span><span class="Punctuation">:</span>
           <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span><span class="Punctuation">)</span>
     <span class="Identifier">assert</span> <span class="Identifier">odd_numbers</span> <span class="Operator">==</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">7</span><span class="Punctuation">,</span> <span class="DecNumber">9</span><span class="Punctuation">]</span><span class="StringLit">&quot;</span>
     <span class="Punctuation">`</span><span class="Punctuation">`</span><span class="Punctuation">`</span></pre></p>
<br/></p>
<h2><a class="toc-backref" id="parsing-idetools-output-sktype" href="#parsing-idetools-output-sktype">skType</a></h2><p><strong>Third column</strong>: module + [n scope nesting] + type name.<br/><strong>Fourth column</strong>: the type.<br/><p><strong>Docstring</strong>: always the empty string.</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">writeTempFile</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">output</span><span class="Punctuation">:</span> <span class="Identifier">File</span>
<span class="Operator">--&gt;</span> <span class="Identifier">col</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">File</span>
    <span class="Identifier">col</span> <span class="DecNumber">3</span><span class="Punctuation">:</span> <span class="Identifier">File</span>
    <span class="Identifier">col</span> <span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&quot;</span></pre></p>
<br/></p>
<h2><a class="toc-backref" id="parsing-idetools-output-skvar" href="#parsing-idetools-output-skvar">skVar</a></h2><p><strong>Third column</strong>: module + [n scope nesting] + var name.<br/><strong>Fourth column</strong>: the type of the var.<br/><p><strong>Docstring</strong>: always the empty string.</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">writeTempFile</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">output</span><span class="Punctuation">:</span> <span class="Identifier">File</span>
  <span class="Identifier">output</span><span class="Operator">.</span><span class="Identifier">open</span><span class="Punctuation">(</span><span class="StringLit">&quot;/tmp/somefile&quot;</span><span class="Punctuation">,</span> <span class="Identifier">fmWrite</span><span class="Punctuation">)</span>
  <span class="Identifier">output</span><span class="Operator">.</span><span class="Identifier">write</span><span class="Punctuation">(</span><span class="StringLit">&quot;test&quot;</span><span class="Punctuation">)</span>
<span class="Operator">--&gt;</span> <span class="Identifier">col</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Operator">$</span><span class="Identifier">MODULE</span><span class="Operator">.</span><span class="Identifier">writeTempFile</span><span class="Operator">.</span><span class="Identifier">output</span>
    <span class="Identifier">col</span> <span class="DecNumber">3</span><span class="Punctuation">:</span> <span class="Identifier">File</span>
    <span class="Identifier">col</span> <span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&quot;</span></pre></p>
<br/></p>
<h1><a class="toc-backref" id="test-suite" href="#test-suite">Test suite</a></h1><p>To verify that idetools is working properly there are files in the <tt class="docutils literal"><span class="pre">tests/caas/</span></tt> directory which provide unit testing. If you find odd idetools behaviour and are able to reproduce it, you are welcome to report it as a bug and add a test to the suite to avoid future regressions.</p>

<h2><a class="toc-backref" id="test-suite-running-the-test-suite" href="#test-suite-running-the-test-suite">Running the test suite</a></h2><p>At the moment idetools support is still in development so the test suite is not integrated with the main test suite and you have to run it manually. First you have to compile the tester:</p>
<p><pre class="listing"><span class="program">$</span> <span class="option">cd</span> <span class="Identifier">my/nim/checkout/tests</span>
<span class="program">$</span> <span class="option">nim</span> <span class="option">c</span> <span class="Identifier">testament/caasdriver.nim</span></pre></p>
<p>Running the <tt class="docutils literal"><span class="pre">caasdriver</span></tt> without parameters will attempt to process all the test cases in all three operation modes. If a test succeeds nothing will be printed and the process will exit with zero. If any test fails, the specific line of the test preceding the failure and the failure itself will be dumped to stdout, along with a final indicator of the success state and operation mode. You can pass the parameter <tt class="docutils literal"><span class="pre">verbose</span></tt> to force all output even on successful tests.</p>
<p>The normal operation mode is called <tt class="docutils literal"><span class="pre">ProcRun</span></tt> and it involves starting a process for each command or query, similar to running manually the Nim compiler from the commandline. The <tt class="docutils literal"><span class="pre">CaasRun</span></tt> mode starts a server process to answer all queries. The <tt class="docutils literal"><span class="pre">SymbolProcRun</span></tt> mode is used by compiler developers.  This means that running all tests involves processing all <tt class="docutils literal"><span class="pre">*.txt</span></tt> files three times, which can be quite time consuming.</p>
<p>If you don't want to run all the test case files you can pass any substring as a parameter to <tt class="docutils literal"><span class="pre">caasdriver</span></tt>. Only files matching the passed substring will be run. The filtering doesn't use any globbing metacharacters, it's a plain match. For example, to run only <tt class="docutils literal"><span class="pre">*-compile*.txt</span></tt> tests in verbose mode:</p>
<p><pre class="listing"><span class="program">./caasdriver</span> <span class="option">verbose</span> <span class="option">-compile</span></pre></p>

<h2><a class="toc-backref" id="test-suite-test-case-file-format" href="#test-suite-test-case-file-format">Test case file format</a></h2><p>All the <tt class="docutils literal"><span class="pre">tests/caas/*.txt</span></tt> files encode a session with the compiler:</p>
<ul class="simple"><li>The first line indicates the main project file.</li>
<li>Lines starting with <tt class="docutils literal"><span class="pre">&gt;</span></tt> indicate a command to be sent to the compiler and the lines following a command include checks for expected or forbidden output (<tt class="docutils literal"><span class="pre">!</span></tt> for forbidden).</li>
<li>If a line starts with <tt class="docutils literal"><span class="pre">#</span></tt> it will be ignored completely, so you can use that for comments.</li>
<li>Since some cases are specific to either <tt class="docutils literal"><span class="pre">ProcRun</span></tt> or <tt class="docutils literal"><span class="pre">CaasRun</span></tt> modes, you can prefix a line with the mode and the line will be processed only in that mode.</li>
<li>The rest of the line is treated as a <a class="reference external" href="re.html">regular expression</a>, so be careful escaping metacharacters like parenthesis.</li>
</ul>
<p>Before the line is processed as a regular expression, some basic variables are searched for and replaced in the tests. The variables which will be replaced are:</p>
<ul class="simple"><li><strong>$TESTNIM</strong>: filename specified in the first line of the script.</li>
<li><strong>$MODULE</strong>: like $TESTNIM but without extension, useful for expected output.</li>
</ul>
<p>When adding a test case to the suite it is a good idea to write a few comments about what the test is meant to verify. </p>
</p>
    
  </div>
</div>

      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br>
        <small style="color: var(--hint);">Made with Nim. Generated: 2024-10-23 19:00:50 UTC</small>
      </div>
    </div>
  </div>
      <script defer data-domain="nim-lang.org" src="https://plausible.io/js/plausible.js"></script>
    
</body>
</html>
