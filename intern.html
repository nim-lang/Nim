<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="https://www.w3.org/1999/xhtml" xml:lang="en" lang="en" data-theme="auto">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Internals of the Nim Compiler</title>

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- CSS -->
<link rel="stylesheet" type="text/css" href="nimdoc.out.css?v=2.2.1">

<!-- JS -->
<script type="text/javascript" src="dochack.js?v=2.2.1"></script>
</head>
<body>
  <div class="document" id="documentId">
    <div class="container">
      <h1 class="title">Internals of the Nim Compiler</h1>
      <div class="row">
  <div class="three columns">
    <div class="theme-select-wrapper">
      <label for="theme-select">Theme:&nbsp;</label>
      <select id="theme-select" onchange="setTheme(this.value)">
        <option value="auto">ðŸŒ— Match OS</option>
        <option value="dark">ðŸŒ‘ Dark</option>
        <option value="light">ðŸŒ• Light</option>
      </select>
    </div>
    <div id="global-links">
      <ul class="simple-boot">
        <li><a href="manual.html">Manual</a></li>
        <li><a href="lib.html">Standard library</a></li>
        <li> <a id="indexLink" href="theindex.html">Index</a></li>
        <li><a href="compiler/theindex.html">Compiler docs</a></li>
        <li><a href="https://nim-lang.github.io/fusion/theindex.html">Fusion docs</a></li>
        <li><a href="https://nim-lang.github.io/Nim/">devel</a>, <a href="https://nim-lang.org/documentation.html">stable</a></li>
      </ul>
    </div>
    <div id="searchInputDiv">
      Search: <input type="search" id="searchInput"
        oninput="search()" />
    </div>
    <div class="search-groupby">
  Group by:
  <select onchange="groupBy(this.value)">
    <option value="section">Section</option>
    <option value="type">Type</option>
  </select>
</div>

    <ul class="simple simple-toc" id="toc-list">
  <li><a class="reference" id="directory-structure_toc" href="#directory-structure">Directory structure</a></li>
<li><a class="reference" id="bootstrapping-the-compiler_toc" href="#bootstrapping-the-compiler">Bootstrapping the compiler</a></li>
<ul class="simple"><li><a class="reference" id="bootstrapping-the-compiler-reproducible-builds_toc" href="#bootstrapping-the-compiler-reproducible-builds">Reproducible builds</a></li>
</ul><li><a class="reference" id="debugging-the-compiler_toc" href="#debugging-the-compiler">Debugging the compiler</a></li>
<ul class="simple"><li><a class="reference" id="debugging-the-compiler-bisecting-for-regressions_toc" href="#debugging-the-compiler-bisecting-for-regressions">Bisecting for regressions</a></li>
<li><a class="reference" id="debugging-the-compiler-building-an-instrumented-compiler_toc" href="#debugging-the-compiler-building-an-instrumented-compiler">Building an instrumented compiler</a></li>
<li><a class="reference" id="debugging-the-compiler-debug-logging_toc" href="#debugging-the-compiler-debug-logging">Debug logging</a></li>
<li><a class="reference" id="debugging-the-compiler-native-debugging_toc" href="#debugging-the-compiler-native-debugging">Native debugging</a></li>
</ul><li><a class="reference" id="the-compiler-s-architecture_toc" href="#the-compiler-s-architecture">The compiler's architecture</a></li>
<ul class="simple"><li><a class="reference" id="the-compiler-s-architecture-short-description-of-nim-s-modules_toc" href="#the-compiler-s-architecture-short-description-of-nim-s-modules">Short description of Nim's modules</a></li>
<li><a class="reference" id="the-compiler-s-architecture-the-syntax-tree_toc" href="#the-compiler-s-architecture-the-syntax-tree">The syntax tree</a></li>
</ul><li><a class="reference" id="runtimes_toc" href="#runtimes">Runtimes</a></li>
<li><a class="reference" id="coding-guidelines_toc" href="#coding-guidelines">Coding Guidelines</a></li>
<li><a class="reference" id="porting-to-new-platforms_toc" href="#porting-to-new-platforms">Porting to new platforms</a></li>
<li><a class="reference" id="runtime-type-information_toc" href="#runtime-type-information">Runtime type information</a></li>
<li><a class="reference" id="magics-and-compilerprocs_toc" href="#magics-and-compilerprocs">Magics and compilerProcs</a></li>
<li><a class="reference" id="code-generation-for-closures_toc" href="#code-generation-for-closures">Code generation for closures</a></li>
<ul class="simple"><li><a class="reference" id="code-generation-for-closures-design_toc" href="#code-generation-for-closures-design">Design</a></li>
<li><a class="reference" id="code-generation-for-closures-accumulator_toc" href="#code-generation-for-closures-accumulator">Accumulator</a></li>
<li><a class="reference" id="code-generation-for-closures-internals_toc" href="#code-generation-for-closures-internals">Internals</a></li>
</ul><li><a class="reference" id="notes-on-type-and-ast-representation_toc" href="#notes-on-type-and-ast-representation">Notes on type and AST representation</a></li>
<ul class="simple"><li><a class="reference" id="notes-on-type-and-ast-representation-integer-literals_toc" href="#notes-on-type-and-ast-representation-integer-literals">Integer literals</a></li>
</ul>
</ul>

  </div>
  <div class="nine columns" id="content">
    <a href="https://github.com/nim-lang/Nim/tree/devel/doc/intern.md#L1" class="link-seesrc" target="_blank">Source</a>&nbsp;&nbsp;
<a href="https://github.com/nim-lang/Nim/edit/devel/doc/intern.md#L1" class="link-seesrc" target="_blank" >Edit</a>&nbsp;&nbsp;

    <div id="tocRoot"></div>
    
    <p class="module-desc"><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">Author:</th><td>Andreas Rumpf</td></tr>
<tr><th class="docinfo-name">Version:</th><td>2.2.1</td></tr>
</tbody></table><blockquote class="markdown-quote"><p>&quot;Abstraction is layering ignorance on top of reality.&quot; -- Richard Gabriel</p></blockquote>

<h1><a class="toc-backref" id="directory-structure" href="#directory-structure">Directory structure</a></h1><p>The Nim project's directory structure is:</p>
<table border="1" class="docutils"><tr><th>Path</th><th>Purpose</th></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">bin</span></span></tt></td><td>generated binary files</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">build</span></span></tt></td><td>generated C code for the installation</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">compiler</span></span></tt></td><td>the Nim compiler itself; note that this code has been translated from a bootstrapping version written in Pascal, so the code is <strong>not</strong> a poster child of good Nim code</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">config</span></span></tt></td><td>configuration files for Nim</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">dist</span></span></tt></td><td>additional packages for the distribution</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">doc</span></span></tt></td><td>the documentation; it is a bunch of reStructuredText files</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">lib</span></span></tt></td><td>the Nim library</td></tr>
</table>
<h1><a class="toc-backref" id="bootstrapping-the-compiler" href="#bootstrapping-the-compiler">Bootstrapping the compiler</a></h1><p><strong>Note</strong>: Add <tt class="docutils literal"><span class="pre">.</span></tt> to your PATH so that <tt class="docutils literal"><span class="pre"><span class="program">koch</span></span></tt> can be used without the <tt class="docutils literal"><span class="pre">./</span></tt>.</p>
<p>Compiling the compiler is a simple matter of running:</p>
<p><pre class="listing"><span class="program">nim</span> <span class="option">c</span> <span class="Identifier">koch.nim</span>
<span class="program">koch</span> <span class="option">boot</span> <span class="option">-d:release</span></pre></p>
<p>For a debug version use:</p>
<p><pre class="listing"><span class="program">nim</span> <span class="option">c</span> <span class="Identifier">koch.nim</span>
<span class="program">koch</span> <span class="option">boot</span></pre></p>
<p>And for a debug version compatible with GDB:</p>
<p><pre class="listing"><span class="program">nim</span> <span class="option">c</span> <span class="Identifier">koch.nim</span>
<span class="program">koch</span> <span class="option">boot</span> <span class="option">--debuginfo</span> <span class="option">--linedir:on</span></pre></p>
<p>The <tt class="docutils literal"><span class="pre"><span class="program">koch</span></span></tt> program is Nim's maintenance script. It is a replacement for make and shell scripting with the advantage that it is much more portable. More information about its options can be found in the <a class="reference external" href="koch.html">koch</a> documentation.</p>

<h2><a class="toc-backref" id="bootstrapping-the-compiler-reproducible-builds" href="#bootstrapping-the-compiler-reproducible-builds">Reproducible builds</a></h2><p>Set the compilation timestamp with the <tt class="docutils literal"><span class="pre"><span class="Identifier">SOURCE_DATE_EPOCH</span></span></tt> environment variable.</p>
<p><pre class="listing"><span class="program">export</span> <span class="option">SOURCE_DATE_EPOCH=$</span><span class="Operator">(</span><span class="program">git</span> <span class="option">log</span> <span class="option">-n</span> <span class="option">1</span> <span class="option">--format=%at</span><span class="Operator">)</span>
<span class="program">koch</span> <span class="option">boot</span> <span class="Comment"># or `./build_all.sh`</span></pre></p>

<h1><a class="toc-backref" id="debugging-the-compiler" href="#debugging-the-compiler">Debugging the compiler</a></h1>
<h2><a class="toc-backref" id="debugging-the-compiler-bisecting-for-regressions" href="#debugging-the-compiler-bisecting-for-regressions">Bisecting for regressions</a></h2><p>There are often times when there is a bug that is caused by a regression in the compiler or stdlib. Bisecting the Nim repo commits is a useful tool to identify what commit introduced the regression.</p>
<p>Even if it's not known whether a bug is caused by a regression, bisection can reduce debugging time by ruling it out. If the bug is found to be a regression, then you focus on the changes introduced by that one specific commit.</p>
<p><tt class="docutils literal"><span class="pre"><span class="program">koch</span> <span class="option">temp</span></span></tt> returns 125 as the exit code in case the compiler compilation fails. This exit code tells <tt class="docutils literal"><span class="pre"><span class="program">git</span> <span class="option">bisect</span></span></tt> to skip the current commit:</p>
<p><pre class="listing"><span class="program">git</span> <span class="option">bisect</span> <span class="option">start</span> <span class="option">bad-commit</span> <span class="option">good-commit</span>
<span class="program">git</span> <span class="option">bisect</span> <span class="option">run</span> <span class="Identifier">./koch</span> <span class="option">temp</span> <span class="option">-r</span> <span class="option">c</span> <span class="Identifier">test-source.nim</span></pre></p>
<p>You can also bisect using custom options to build the compiler, for example if you don't need a debug version of the compiler (which runs slower), you can replace <tt class="docutils literal"><span class="pre"><span class="program">./koch</span> <span class="option">temp</span></span></tt> by explicit compilation command, see <a class="reference internal" href="#bootstrapping-the-compiler">Bootstrapping the compiler</a>.</p>
<p>See also:</p>
<ul class="simple"><li>Crossplatform C/Cpp/Valgrind/JS Bisect in GitHub: <a class="reference external" href="https://github.com/juancarlospaco/nimrun-action#examples">https://github.com/juancarlospaco/nimrun-action#examples</a></li>
</ul>

<h2><a class="toc-backref" id="debugging-the-compiler-building-an-instrumented-compiler" href="#debugging-the-compiler-building-an-instrumented-compiler">Building an instrumented compiler</a></h2><p>Considering that a useful method of debugging the compiler is inserting debug logging, or changing code and then observing the outcome of a testcase, it is fastest to build a compiler that is instrumented for debugging from an existing release build. <tt class="docutils literal"><span class="pre"><span class="program">koch</span> <span class="option">temp</span></span></tt> provides a convenient method of doing just that.</p>
<p>By default, running <tt class="docutils literal"><span class="pre"><span class="program">koch</span> <span class="option">temp</span></span></tt> will build a lean version of the compiler with <tt class="docutils literal"><span class="pre option">-d:debug</span></tt> enabled. The compiler is written to <tt class="docutils literal"><span class="pre"><span class="Identifier">bin</span><span class="Operator">/</span><span class="Identifier">nim_temp</span></span></tt> by default. A lean version of the compiler lacks JS and documentation generation.</p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">bin</span><span class="Operator">/</span><span class="Identifier">nim_temp</span></span></tt> can be directly used to run testcases, or used with testament with <tt class="docutils literal"><span class="pre"><span class="program">testament</span> <span class="Identifier">--nim:bin/nim_temp</span> <span class="option">r</span> <span class="Identifier">tests/category/tsometest</span></span></tt>.</p>
<p><tt class="docutils literal"><span class="pre"><span class="program">koch</span> <span class="option">temp</span></span></tt> will build the temporary compiler with the <tt class="docutils literal"><span class="pre option">-d:debug</span></tt> enabled. Here are compiler options that are of interest when debugging:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre option">-d:debug</span></tt>: enables <tt class="docutils literal"><span class="pre"><span class="Identifier">assert</span></span></tt> statements and stacktraces and all runtime checks</li>
<li><tt class="docutils literal"><span class="pre option">--opt:speed</span></tt>: build with optimizations enabled</li>
<li><tt class="docutils literal"><span class="pre option">--debugger:native</span></tt>: enables <tt class="docutils literal"><span class="pre option">--debuginfo --lineDir:on</span></tt> for using a native debugger like GDB, LLDB or CDB</li>
<li><tt class="docutils literal"><span class="pre option">-d:nimDebug</span></tt> cause calls to <tt class="docutils literal"><span class="pre"><span class="Identifier">quit</span></span></tt> to raise an assertion exception</li>
<li><tt class="docutils literal"><span class="pre option">-d:nimDebugUtils</span></tt>: enables various debugging utilities; see <tt class="docutils literal"><span class="pre"><span class="Identifier">compiler</span><span class="Operator">/</span><span class="Identifier">debugutils</span></span></tt></li>
<li><tt class="docutils literal"><span class="pre option">-d:stacktraceMsgs -d:nimCompilerStacktraceHints</span></tt>: adds some additional stacktrace hints; see <a class="reference external" href="https://github.com/nim-lang/Nim/pull/13351">https://github.com/nim-lang/Nim/pull/13351</a></li>
<li><tt class="docutils literal"><span class="pre option">-u:leanCompiler</span></tt>: enable JS and doc generation</li>
</ul>
<p>Another method to build and run the compiler is directly through <tt class="docutils literal"><span class="pre"><span class="program">koch</span></span></tt>:</p>
<p><pre class="listing"><span class="program">koch</span> <span class="option">temp</span> <span class="option">[options]</span> <span class="option">c</span> <span class="Identifier">test.nim</span>

<span class="Comment"># (will build with js support)</span>
<span class="program">koch</span> <span class="option">temp</span> <span class="option">[options]</span> <span class="option">js</span> <span class="Identifier">test.nim</span>

<span class="Comment"># (will build with doc support)</span>
<span class="program">koch</span> <span class="option">temp</span> <span class="option">[options]</span> <span class="option">doc</span> <span class="Identifier">test.nim</span></pre></p>

<h2><a class="toc-backref" id="debugging-the-compiler-debug-logging" href="#debugging-the-compiler-debug-logging">Debug logging</a></h2><p>&quot;Printf debugging&quot; is still the most appropriate way to debug many problems arising in compiler development. The typical usage of breakpoints to debug the code is often less practical, because almost all code paths in the compiler will be executed hundreds of times before a particular section of the tested program is reached where the newly developed code must be activated.</p>
<p>To work around this problem, you'll typically introduce an if statement in the compiler code detecting more precisely the conditions where the tested feature is being used. One very common way to achieve this is to use the <tt class="docutils literal"><span class="pre"><span class="Identifier">mdbg</span></span></tt> condition, which will be true only in contexts, processing expressions and statements from the currently compiled main module:</p>
<p><pre class="listing"><span class="Comment"># inside some compiler module</span>
<span class="Keyword">if</span> <span class="Identifier">mdbg</span><span class="Punctuation">:</span>
  <span class="Identifier">debug</span> <span class="Identifier">someAstNode</span></pre></p>
<p>Using the <tt class="docutils literal"><span class="pre"><span class="Identifier">isCompilerDebug</span></span></tt> condition along with inserting some statements into the testcase provides more granular logging:</p>
<p><pre class="listing"><span class="Comment"># compilermodule.nim</span>
<span class="Keyword">if</span> <span class="Identifier">isCompilerDebug</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">debug</span> <span class="Identifier">someAstNode</span>

<span class="Comment"># testcase.nim</span>
<span class="Keyword">proc</span> <span class="Identifier">main</span> <span class="Operator">=</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">define</span><span class="Punctuation">(</span><span class="Identifier">nimCompilerDebug</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">let</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="FloatNumber">2.5</span> <span class="Operator">*</span> <span class="DecNumber">3</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">undef</span><span class="Punctuation">(</span><span class="Identifier">nimCompilerDebug</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>
<p>Logging can also be scoped to a specific filename as well. This will of course match against every module with that name.</p>
<p><pre class="listing"><span class="Keyword">if</span> <span class="Punctuation">`</span><span class="Operator">??</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">conf</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">info</span><span class="Punctuation">,</span> <span class="StringLit">&quot;module.nim&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">)</span></pre></p>
<p>The above examples also makes use of the <tt class="docutils literal"><span class="pre"><span class="Identifier">debug</span></span></tt> proc, which is able to print a human-readable form of an arbitrary AST tree. Other common ways to print information about the internal compiler types include:</p>
<p><pre class="listing"><span class="Comment"># pretty print PNode</span>

<span class="Comment"># pretty prints the Nim ast</span>
<span class="Identifier">echo</span> <span class="Identifier">renderTree</span><span class="Punctuation">(</span><span class="Identifier">someNode</span><span class="Punctuation">)</span>

<span class="Comment"># pretty prints the Nim ast, but annotates symbol IDs</span>
<span class="Identifier">echo</span> <span class="Identifier">renderTree</span><span class="Punctuation">(</span><span class="Identifier">someNode</span><span class="Punctuation">,</span> <span class="Punctuation">{</span><span class="Identifier">renderIds</span><span class="Punctuation">}</span><span class="Punctuation">)</span>

<span class="Comment"># pretty print ast as JSON</span>
<span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">someNode</span><span class="Punctuation">)</span>

<span class="Comment"># print as YAML</span>
<span class="Identifier">echo</span> <span class="Identifier">treeToYaml</span><span class="Punctuation">(</span><span class="Identifier">config</span><span class="Punctuation">,</span> <span class="Identifier">someNode</span><span class="Punctuation">)</span>


<span class="Comment"># pretty print PType</span>

<span class="Comment"># print type name</span>
<span class="Identifier">echo</span> <span class="Identifier">typeToString</span><span class="Punctuation">(</span><span class="Identifier">someType</span><span class="Punctuation">)</span>

<span class="Comment"># pretty print as JSON</span>
<span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">someType</span><span class="Punctuation">)</span>

<span class="Comment"># print as YAML</span>
<span class="Identifier">echo</span> <span class="Identifier">typeToYaml</span><span class="Punctuation">(</span><span class="Identifier">config</span><span class="Punctuation">,</span> <span class="Identifier">someType</span><span class="Punctuation">)</span>


<span class="Comment"># pretty print PSym</span>

<span class="Comment"># print the symbol's name</span>
<span class="Identifier">echo</span> <span class="Identifier">symbol</span><span class="Operator">.</span><span class="Identifier">name</span><span class="Operator">.</span><span class="Identifier">s</span>

<span class="Comment"># pretty print as JSON</span>
<span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">symbol</span><span class="Punctuation">)</span>

<span class="Comment"># print as YAML</span>
<span class="Identifier">echo</span> <span class="Identifier">symToYaml</span><span class="Punctuation">(</span><span class="Identifier">config</span><span class="Punctuation">,</span> <span class="Identifier">symbol</span><span class="Punctuation">)</span>


<span class="Comment"># pretty print TLineInfo</span>
<span class="Identifier">lineInfoToStr</span><span class="Punctuation">(</span><span class="Identifier">lineInfo</span><span class="Punctuation">)</span>


<span class="Comment"># print the structure of any type</span>
<span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">someVar</span><span class="Punctuation">)</span></pre></p>
<p>Here are some other helpful utilities:</p>
<p><pre class="listing"><span class="Comment"># how did execution reach this location?</span>
<span class="Identifier">writeStackTrace</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>
<p>These procs may not already be imported by the module you're editing. You can import them directly for debugging:</p>
<p><pre class="listing"><span class="Keyword">from</span> <span class="Identifier">astalgo</span> <span class="Keyword">import</span> <span class="Identifier">debug</span>
<span class="Keyword">from</span> <span class="Identifier">types</span> <span class="Keyword">import</span> <span class="Identifier">typeToString</span>
<span class="Keyword">from</span> <span class="Identifier">renderer</span> <span class="Keyword">import</span> <span class="Identifier">renderTree</span>
<span class="Keyword">from</span> <span class="Identifier">msgs</span> <span class="Keyword">import</span> <span class="Punctuation">`</span><span class="Operator">??</span><span class="Punctuation">`</span></pre></p>

<h2><a class="toc-backref" id="debugging-the-compiler-native-debugging" href="#debugging-the-compiler-native-debugging">Native debugging</a></h2><p>Stepping through the compiler with a native debugger is a very powerful tool to both learn and debug it. However, there is still the need to constrain when breakpoints are triggered. The same methods as in <a class="reference internal" href="#debugging-the-compiler-debug-logging">Debug logging</a> can be applied here when combined with calls to the debug helpers <tt class="docutils literal"><span class="pre"><span class="Identifier">enteringDebugSection</span><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">exitingDebugSection</span><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt>.</p>
<ol class="simple"><li>Compile the temp compiler with <tt class="docutils literal"><span class="pre option">--debugger:native -d:nimDebugUtils</span></tt></li>
<li>Set your desired breakpoints or watchpoints.</li>
<li>Configure your debugger:<ul class="simple"><li>GDB: execute <tt class="docutils literal"><span class="pre"><span class="Identifier">source</span> <span class="Identifier">tools</span><span class="Operator">/</span><span class="Identifier">compiler</span><span class="Operator">.</span><span class="Identifier">gdb</span></span></tt> at startup</li>
<li>LLDB execute <tt class="docutils literal"><span class="pre"><span class="Identifier">command</span> <span class="Identifier">source</span> <span class="Identifier">tools</span><span class="Operator">/</span><span class="Identifier">compiler</span><span class="Operator">.</span><span class="Identifier">lldb</span></span></tt> at startup</li>
</ul>
</li>
<li>Use one of the scoping helpers like so:</li>
</ol>
<p><pre class="listing"><span class="Keyword">if</span> <span class="Identifier">isCompilerDebug</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">enteringDebugSection</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">exitingDebugSection</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>
<p>A caveat of this method is that all breakpoints and watchpoints are enabled or disabled. Also, due to a bug, only breakpoints can be constrained for LLDB.</p>

<h1><a class="toc-backref" id="the-compiler-s-architecture" href="#the-compiler-s-architecture">The compiler's architecture</a></h1><p>Nim uses the classic compiler architecture: A lexer/scanner feeds tokens to a parser. The parser builds a syntax tree that is used by the code generators. This syntax tree is the interface between the parser and the code generator. It is essential to understand most of the compiler's code.</p>
<p>Semantic analysis is separated from parsing.</p>

<h2><a class="toc-backref" id="the-compiler-s-architecture-short-description-of-nim-s-modules" href="#the-compiler-s-architecture-short-description-of-nim-s-modules">Short description of Nim's modules</a></h2><table border="1" class="docutils"><tr><th>Module</th><th>Description</th></tr>
<tr><td>nim</td><td>main module: parses the command line and calls <tt class="docutils literal"><span class="pre"><span class="Identifier">main</span><span class="Operator">.</span><span class="Identifier">MainCommand</span></span></tt></td></tr>
<tr><td>main</td><td>implements the top-level command dispatching</td></tr>
<tr><td>nimconf</td><td>implements the config file reader</td></tr>
<tr><td>syntaxes</td><td>dispatcher for the different parsers and filters</td></tr>
<tr><td>filter_tmpl</td><td>standard template filter (<tt class="docutils literal"><span class="pre">#? stdtempl</span></tt>)</td></tr>
<tr><td>lexbase</td><td>buffer handling of the lexical analyser</td></tr>
<tr><td>lexer</td><td>lexical analyser</td></tr>
<tr><td>parser</td><td>Nim's parser</td></tr>
<tr><td>renderer</td><td>Nim code renderer (AST back to its textual form)</td></tr>
<tr><td>options</td><td>contains global and local compiler options</td></tr>
<tr><td>ast</td><td>type definitions of the abstract syntax tree (AST) and node constructors</td></tr>
<tr><td>astalgo</td><td>algorithms for containers of AST nodes; converting the AST to YAML; the symbol table</td></tr>
<tr><td>passes</td><td>implement the passes manager for passes over the AST</td></tr>
<tr><td>trees</td><td>some algorithms for nodes; this module is less important</td></tr>
<tr><td>types</td><td>module for traversing type graphs; also contain several helpers for dealing with types</td></tr>
<tr><td></td><td></td></tr>
<tr><td>sigmatch</td><td>contains the matching algorithm that is used for proc calls</td></tr>
<tr><td>semexprs</td><td>contains the semantic checking phase for expressions</td></tr>
<tr><td>semstmts</td><td>contains the semantic checking phase for statements</td></tr>
<tr><td>semtypes</td><td>contains the semantic checking phase for types</td></tr>
<tr><td>seminst</td><td>instantiation of generic procs and types</td></tr>
<tr><td>semfold</td><td>contains code to deal with constant folding</td></tr>
<tr><td>sempass2</td><td>Second semantic checking pass over the AST</td></tr>
<tr><td>vm</td><td>contains an AST interpreter for compile time evaluation</td></tr>
<tr><td>pragmas</td><td>semantic checking of pragmas</td></tr>
<tr><td></td><td></td></tr>
<tr><td>idents</td><td>implements a general mapping from identifiers to an internal representation (<tt class="docutils literal"><span class="pre"><span class="Identifier">PIdent</span></span></tt>) that is used so that a simple id-comparison suffices to establish whether two Nim identifiers are equivalent</td></tr>
<tr><td></td><td></td></tr>
<tr><td>transf</td><td>transformations on the AST that need to be done before code generation</td></tr>
<tr><td>cgen</td><td>main file of the C code generator</td></tr>
<tr><td>ccgutils</td><td>contains helpers for the C code generator</td></tr>
<tr><td>ccgtypes</td><td>the generator for C types</td></tr>
<tr><td>ccgstmts</td><td>the generator for statements</td></tr>
<tr><td>ccgexprs</td><td>the generator for expressions</td></tr>
<tr><td>extccomp</td><td>this module calls the C compiler and linker; interesting if you want to add support for a new C compiler</td></tr>
</table>
<h2><a class="toc-backref" id="the-compiler-s-architecture-the-syntax-tree" href="#the-compiler-s-architecture-the-syntax-tree">The syntax tree</a></h2><p>The syntax tree consists of nodes which may have an arbitrary number of children. Types and symbols are represented by other nodes, because they may contain cycles. The AST changes its shape after semantic checking. This is needed to make life easier for the code generators. See the &quot;ast&quot; module for the type definitions. The <a class="reference external" href="macros.html">macros</a> module contains many examples how the AST represents each syntactic structure.</p>

<h1><a class="toc-backref" id="runtimes" href="#runtimes">Runtimes</a></h1><p>Nim has two different runtimes, the &quot;old runtime&quot; and the &quot;new runtime&quot;. The old runtime supports the old GCs (markAndSweep, refc, Boehm), the new runtime supports ARC/ORC. The new runtime is active <tt class="docutils literal"><span class="pre"><span class="Keyword">when</span> <span class="Identifier">defined</span><span class="Punctuation">(</span><span class="Identifier">nimV2</span><span class="Punctuation">)</span></span></tt>.</p>

<h1><a class="toc-backref" id="coding-guidelines" href="#coding-guidelines">Coding Guidelines</a></h1><ul class="simple"><li>We follow Nim's official style guide, see <a class="reference external" href="nep1.html">NEP1</a>.</li>
<li>Max line length is 100 characters.</li>
<li>Provide spaces around binary operators if that enhances readability.</li>
<li>Use a space after a colon, but not before it.</li>
<li>(deprecated) Start types with a capital <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span></span></tt>, unless they are pointers/references which start with <tt class="docutils literal"><span class="pre"><span class="Identifier">P</span></span></tt>.</li>
<li>Prefer <tt class="docutils literal"><span class="pre"><span class="Keyword">import</span> <span class="Identifier">package</span></span></tt> over <tt class="docutils literal"><span class="pre"><span class="Keyword">from</span> <span class="Identifier">package</span> <span class="Keyword">import</span> <span class="Identifier">symbol</span></span></tt>.</li>
</ul>
<p>See also the <a class="reference external" href="apis.html">API naming design</a> document.</p>

<h1><a class="toc-backref" id="porting-to-new-platforms" href="#porting-to-new-platforms">Porting to new platforms</a></h1><p>Porting Nim to a new architecture is pretty easy, since C is the most portable programming language (within certain limits) and Nim generates C code, porting the code generator is not necessary.</p>
<p>POSIX-compliant systems on conventional hardware are usually pretty easy to port: Add the platform to <tt class="docutils literal"><span class="pre"><span class="Identifier">platform</span></span></tt> (if it is not already listed there), check that the OS, System modules work and recompile Nim.</p>
<p>The only case where things aren't as easy is when old runtime's garbage collectors need some assembler tweaking to work. The default implementation uses C's <tt class="docutils literal"><span class="pre"><span class="Identifier">setjmp</span></span></tt> function to store all registers on the hardware stack. It may be necessary that the new platform needs to replace this generic code by some assembler code.</p>
<p>Files that may need changed for your platform include:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre"><span class="Identifier">compiler</span><span class="Operator">/</span><span class="Identifier">platform</span><span class="Operator">.</span><span class="Identifier">nim</span></span></tt> Add os/cpu properties.</li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">lib</span><span class="Operator">/</span><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">nim</span></span></tt> Add os/cpu to the documentation for <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">hostOS</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">hostCPU</span></span></tt>.</li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">compiler</span><span class="Operator">/</span><span class="Identifier">options</span><span class="Operator">.</span><span class="Identifier">nim</span></span></tt> Add special os/cpu property checks in <tt class="docutils literal"><span class="pre"><span class="Identifier">isDefined</span></span></tt>.</li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">compiler</span><span class="Operator">/</span><span class="Identifier">installer</span><span class="Operator">.</span><span class="Identifier">ini</span></span></tt> Add os/cpu to <tt class="docutils literal"><span class="pre"><span class="Identifier">Project</span><span class="Operator">.</span><span class="Identifier">Platforms</span></span></tt> field.</li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">lib</span><span class="Operator">/</span><span class="Identifier">system</span><span class="Operator">/</span><span class="Identifier">platforms</span><span class="Operator">.</span><span class="Identifier">nim</span></span></tt> Add os/cpu.</li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">private</span><span class="Operator">/</span><span class="Identifier">osseps</span><span class="Operator">.</span><span class="Identifier">nim</span></span></tt> Add os specializations.</li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">lib</span><span class="Operator">/</span><span class="Identifier">pure</span><span class="Operator">/</span><span class="Identifier">distros</span><span class="Operator">.</span><span class="Identifier">nim</span></span></tt> Add os, package handler.</li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">tools</span><span class="Operator">/</span><span class="Identifier">niminst</span><span class="Operator">/</span><span class="Identifier">makefile</span><span class="Operator">.</span><span class="Identifier">nimf</span></span></tt> Add os/cpu compiler/linker flags.</li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">tools</span><span class="Operator">/</span><span class="Identifier">niminst</span><span class="Operator">/</span><span class="Identifier">buildsh</span><span class="Operator">.</span><span class="Identifier">nimf</span></span></tt> Add os/cpu compiler/linker flags.</li>
</ul>
<p>If the <tt class="docutils literal"><span class="pre"><span class="Operator">--</span><span class="Identifier">os</span></span></tt> or <tt class="docutils literal"><span class="pre"><span class="Operator">--</span><span class="Identifier">cpu</span></span></tt> options aren't passed to the compiler, then Nim will determine the current host os, cpu and endianness from <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">cpuEndian</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">hostOS</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">hostCPU</span></span></tt>. Those values are derived from <tt class="docutils literal"><span class="pre"><span class="Identifier">compiler</span><span class="Operator">/</span><span class="Identifier">platform</span><span class="Operator">.</span><span class="Identifier">nim</span></span></tt>.</p>
<p>In order for the new platform to be bootstrapped from the <tt class="docutils literal"><span class="pre"><span class="Identifier">csources</span></span></tt>, it must:</p>
<ul class="simple"><li>have <tt class="docutils literal"><span class="pre"><span class="Identifier">compiler</span><span class="Operator">/</span><span class="Identifier">platform</span><span class="Operator">.</span><span class="Identifier">nim</span></span></tt> updated</li>
<li>have <tt class="docutils literal"><span class="pre"><span class="Identifier">compiler</span><span class="Operator">/</span><span class="Identifier">installer</span><span class="Operator">.</span><span class="Identifier">ini</span></span></tt> updated</li>
<li>have <tt class="docutils literal"><span class="pre"><span class="Identifier">tools</span><span class="Operator">/</span><span class="Identifier">niminst</span><span class="Operator">/</span><span class="Identifier">buildsh</span><span class="Operator">.</span><span class="Identifier">nimf</span></span></tt> updated</li>
<li>have <tt class="docutils literal"><span class="pre"><span class="Identifier">tools</span><span class="Operator">/</span><span class="Identifier">niminst</span><span class="Operator">/</span><span class="Identifier">makefile</span><span class="Operator">.</span><span class="Identifier">nimf</span></span></tt> updated</li>
<li>be backported to the Nim version used by the <tt class="docutils literal"><span class="pre"><span class="Identifier">csources</span></span></tt></li>
<li>the new <tt class="docutils literal"><span class="pre"><span class="Identifier">csources</span></span></tt> must be pushed</li>
<li>the new <tt class="docutils literal"><span class="pre"><span class="Identifier">csources</span></span></tt> revision must be updated in <tt class="docutils literal"><span class="pre"><span class="Identifier">config</span><span class="Operator">/</span><span class="Identifier">build_config</span><span class="Operator">.</span><span class="Identifier">txt</span></span></tt></li>
</ul>

<h1><a class="toc-backref" id="runtime-type-information" href="#runtime-type-information">Runtime type information</a></h1><p><strong>Note</strong>: This section describes the &quot;old runtime&quot;.</p>
<p><em>Runtime type information</em> (RTTI) is needed for several aspects of the Nim programming language:</p>
<dl class="docutils"><dt>Garbage collection</dt>
<dd>The old GCs use the RTTI for traversing arbitrary Nim types, but usually only the <tt class="docutils literal"><span class="pre"><span class="Identifier">marker</span></span></tt> field which contains a proc that does the traversal.</dd>
<dt>Complex assignments</dt>
<dd>Sequences and strings are implemented as pointers to resizable buffers, but Nim requires copying for assignments. Apart from RTTI the compiler also generates copy procedures as a specialization.</dd>
</dl>
<p>We already know the type information as a graph in the compiler. Thus, we need to serialize this graph as RTTI for C code generation. Look at the file <tt class="docutils literal"><span class="pre">lib/system/hti.nim</span></tt> for more information.</p>

<h1><a class="toc-backref" id="magics-and-compilerprocs" href="#magics-and-compilerprocs">Magics and compilerProcs</a></h1><p>The <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span></span></tt> module contains the part of the RTL which needs support by compiler magic. The C code generator generates the C code for it, just like any other module. However, calls to some procedures like <tt class="docutils literal"><span class="pre"><span class="Identifier">addInt</span></span></tt> are inserted by the generator. Therefore, there is a table (<tt class="docutils literal"><span class="pre"><span class="Identifier">compilerprocs</span></span></tt>) with all symbols that are marked as <tt class="docutils literal"><span class="pre"><span class="Identifier">compilerproc</span></span></tt>. <tt class="docutils literal"><span class="pre"><span class="Identifier">compilerprocs</span></span></tt> are needed by the code generator. A <tt class="docutils literal"><span class="pre"><span class="Identifier">magic</span></span></tt> proc is not the same as a <tt class="docutils literal"><span class="pre"><span class="Identifier">compilerproc</span></span></tt>: A <tt class="docutils literal"><span class="pre"><span class="Identifier">magic</span></span></tt> is a proc that needs compiler magic for its semantic checking, a <tt class="docutils literal"><span class="pre"><span class="Identifier">compilerproc</span></span></tt> is a proc that is used by the code generator.</p>

<h1><a class="toc-backref" id="code-generation-for-closures" href="#code-generation-for-closures">Code generation for closures</a></h1><p>Code generation for closures is implemented by <span id="lambda-lifting_1">lambda lifting</span>.</p>

<h2><a class="toc-backref" id="code-generation-for-closures-design" href="#code-generation-for-closures-design">Design</a></h2><p>A <tt class="docutils literal"><span class="pre"><span class="Identifier">closure</span></span></tt> proc var can call ordinary procs of the default Nim calling convention. But not the other way round! A closure is implemented as a <tt class="docutils literal"><span class="pre"><span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">prc</span><span class="Punctuation">,</span> <span class="Identifier">env</span><span class="Punctuation">]</span></span></tt>. <tt class="docutils literal"><span class="pre"><span class="Identifier">env</span></span></tt> can be nil implying a call without a closure. This means that a call through a closure generates an <tt class="docutils literal"><span class="pre"><span class="Keyword">if</span></span></tt> but the interoperability is worth the cost of the <tt class="docutils literal"><span class="pre"><span class="Keyword">if</span></span></tt>. Thunk generation would be possible too, but it's slightly more effort to implement.</p>
<p>Tests with GCC on Amd64 showed that it's really beneficial if the 'environment' pointer is passed as the last argument, not as the first argument.</p>
<p>Proper thunk generation is harder because the proc that is to wrap could stem from a complex expression:</p>
<p><pre class="listing"><span class="Identifier">receivesClosure</span><span class="Punctuation">(</span><span class="Identifier">returnsDefaultCC</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre></p>
<p>A thunk would need to call <tt class="docutils literal"><span class="pre"><span class="Identifier">returnsDefaultCC</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></span></tt> somehow and that would require an <em>additional</em> closure generation... Ok, not really, but it requires to pass the function to call. So we'd end up with 2 indirect calls instead of one. Another much more severe problem with this solution is that it's not GC-safe to pass a proc pointer around via a generic <tt class="docutils literal"><span class="pre"><span class="Keyword">ref</span></span></tt> type.</p>
<p>Example code:</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">return</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
    <span class="Keyword">return</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>

<span class="Keyword">var</span> <span class="Identifier">add2</span> <span class="Operator">=</span> <span class="Identifier">add</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">add2</span><span class="Punctuation">(</span><span class="DecNumber">5</span><span class="Punctuation">)</span> <span class="Comment">#OUT 7</span></pre></p>
<p>This should produce roughly this code:</p>
<p><pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Env</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment"># data</span>

<span class="Keyword">proc</span> <span class="Identifier">anon</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">Env</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">return</span> <span class="Identifier">y</span> <span class="Operator">+</span> <span class="Identifier">c</span><span class="Operator">.</span><span class="Identifier">x</span>

<span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">prc</span><span class="Punctuation">,</span> <span class="Identifier">data</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">env</span><span class="Punctuation">:</span> <span class="Identifier">Env</span>
  <span class="Identifier">new</span> <span class="Identifier">env</span>
  <span class="Identifier">env</span><span class="Operator">.</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">x</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">anon</span><span class="Punctuation">,</span> <span class="Identifier">env</span><span class="Punctuation">)</span>

<span class="Keyword">var</span> <span class="Identifier">add2</span> <span class="Operator">=</span> <span class="Identifier">add</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span>
<span class="Keyword">let</span> <span class="Identifier">tmp</span> <span class="Operator">=</span> <span class="Keyword">if</span> <span class="Identifier">add2</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span> <span class="Identifier">add2</span><span class="Operator">.</span><span class="Identifier">prc</span><span class="Punctuation">(</span><span class="DecNumber">5</span><span class="Punctuation">)</span> <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">add2</span><span class="Operator">.</span><span class="Identifier">prc</span><span class="Punctuation">(</span><span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">add2</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">tmp</span></pre></p>
<p>Beware of nesting:</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">return</span> <span class="Identifier">lambda</span> <span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
    <span class="Keyword">return</span> <span class="Identifier">lambda</span> <span class="Punctuation">(</span><span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
      <span class="Keyword">return</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span> <span class="Operator">+</span> <span class="Identifier">z</span>

<span class="Keyword">var</span> <span class="Identifier">add24</span> <span class="Operator">=</span> <span class="Identifier">add</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">add24</span><span class="Punctuation">(</span><span class="DecNumber">5</span><span class="Punctuation">)</span> <span class="Comment">#OUT 11</span></pre></p>
<p>This should produce roughly this code:</p>
<p><pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">EnvX</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment"># data</span>
  
  <span class="Identifier">EnvY</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
    <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">ex</span><span class="Punctuation">:</span> <span class="Identifier">EnvX</span>

<span class="Keyword">proc</span> <span class="Identifier">lambdaZ</span><span class="Punctuation">(</span><span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">ey</span><span class="Punctuation">:</span> <span class="Identifier">EnvY</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">return</span> <span class="Identifier">ey</span><span class="Operator">.</span><span class="Identifier">ex</span><span class="Operator">.</span><span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">ey</span><span class="Operator">.</span><span class="Identifier">y</span> <span class="Operator">+</span> <span class="Identifier">z</span>

<span class="Keyword">proc</span> <span class="Identifier">lambdaY</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">ex</span><span class="Punctuation">:</span> <span class="Identifier">EnvX</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">prc</span><span class="Punctuation">,</span> <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">EnvY</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">ey</span><span class="Punctuation">:</span> <span class="Identifier">EnvY</span>
  <span class="Identifier">new</span> <span class="Identifier">ey</span>
  <span class="Identifier">ey</span><span class="Operator">.</span><span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">y</span>
  <span class="Identifier">ey</span><span class="Operator">.</span><span class="Identifier">ex</span> <span class="Operator">=</span> <span class="Identifier">ex</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">lambdaZ</span><span class="Punctuation">,</span> <span class="Identifier">ey</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">prc</span><span class="Punctuation">,</span> <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">EnvX</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">ex</span><span class="Punctuation">:</span> <span class="Identifier">EnvX</span>
  <span class="Identifier">ex</span><span class="Operator">.</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">x</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">lambdaY</span><span class="Punctuation">,</span> <span class="Identifier">ex</span><span class="Punctuation">)</span>

<span class="Keyword">var</span> <span class="Identifier">tmp</span> <span class="Operator">=</span> <span class="Identifier">add</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">tmp2</span> <span class="Operator">=</span> <span class="Identifier">tmp</span><span class="Operator">.</span><span class="Identifier">fn</span><span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="Identifier">tmp</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">add24</span> <span class="Operator">=</span> <span class="Identifier">tmp2</span><span class="Operator">.</span><span class="Identifier">fn</span><span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="Identifier">tmp2</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">add24</span><span class="Punctuation">(</span><span class="DecNumber">5</span><span class="Punctuation">)</span></pre></p>
<p>We could get rid of nesting environments by always inlining inner anon procs. More useful is escape analysis and stack allocation of the environment, however.</p>

<h2><a class="toc-backref" id="code-generation-for-closures-accumulator" href="#code-generation-for-closures-accumulator">Accumulator</a></h2><p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">getAccumulator</span><span class="Punctuation">(</span><span class="Identifier">start</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="Identifier">start</span>
  <span class="Keyword">return</span> <span class="Identifier">lambda</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
    <span class="Identifier">inc</span> <span class="Identifier">i</span>
    <span class="Keyword">return</span> <span class="Identifier">i</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">delta</span> <span class="Operator">=</span> <span class="DecNumber">7</span>
  <span class="Keyword">proc</span> <span class="Identifier">accumulator</span><span class="Punctuation">(</span><span class="Identifier">start</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">proc</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
    <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">start</span><span class="Operator">-</span><span class="DecNumber">1</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
      <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">delta</span>
      <span class="Identifier">inc</span> <span class="Identifier">delta</span>
      <span class="Keyword">return</span> <span class="Identifier">x</span>
  
  <span class="Keyword">var</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">accumulator</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span>
  <span class="Keyword">var</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">accumulator</span><span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">)</span>
  <span class="Identifier">echo</span> <span class="Identifier">a</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">b</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>

<h2><a class="toc-backref" id="code-generation-for-closures-internals" href="#code-generation-for-closures-internals">Internals</a></h2><p>Lambda lifting is implemented as part of the <tt class="docutils literal"><span class="pre"><span class="Identifier">transf</span></span></tt> pass. The <tt class="docutils literal"><span class="pre"><span class="Identifier">transf</span></span></tt> pass generates code to set up the environment and to pass it around. However, this pass does not change the types! So we have some kind of mismatch here; on the one hand the proc expression becomes an explicit tuple, on the other hand the tyProc(ccClosure) type is not changed. For C code generation it's also important the hidden formal param is <tt class="docutils literal"><span class="pre"><span class="Keyword">void</span><span class="Operator">*</span></span></tt> and not something more specialized. However, the more specialized env type needs to passed to the backend somehow. We deal with this by modifying <tt class="docutils literal"><span class="pre"><span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">ast</span><span class="Punctuation">[</span><span class="Identifier">paramPos</span><span class="Punctuation">]</span></span></tt> to contain the formal hidden parameter, but not <tt class="docutils literal"><span class="pre"><span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">typ</span></span></tt>!</p>

<h1><a class="toc-backref" id="notes-on-type-and-ast-representation" href="#notes-on-type-and-ast-representation">Notes on type and AST representation</a></h1><p>To be expanded.</p>

<h2><a class="toc-backref" id="notes-on-type-and-ast-representation-integer-literals" href="#notes-on-type-and-ast-representation-integer-literals">Integer literals</a></h2><p>In Nim, there is a redundant way to specify the type of an integer literal. First, it should be unsurprising that every node has a node kind. The node of an integer literal can be any of the following values:</p>
<pre>nkIntLit, nkInt8Lit, nkInt16Lit, nkInt32Lit, nkInt64Lit,
nkUIntLit, nkUInt8Lit, nkUInt16Lit, nkUInt32Lit, nkUInt64Lit</pre>
<p>On top of that, there is also the <tt class="docutils literal"><span class="pre"><span class="Identifier">typ</span></span></tt> field for the type. The kind of the <tt class="docutils literal"><span class="pre"><span class="Identifier">typ</span></span></tt> field can be one of the following ones, and it should be matching the literal kind:</p>
<pre>tyInt, tyInt8, tyInt16, tyInt32, tyInt64, tyUInt, tyUInt8,
tyUInt16, tyUInt32, tyUInt64</pre>
<p>Then there is also the integer literal type. This is a specific type that is implicitly convertible into the requested type if the requested type can hold the value. For this to work, the type needs to know the concrete value of the literal. For example an expression <tt class="docutils literal"><span class="pre"><span class="DecNumber">321</span></span></tt> will be of type <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span> <span class="Identifier">literal</span><span class="Punctuation">(</span><span class="DecNumber">321</span><span class="Punctuation">)</span></span></tt>. This type is implicitly convertible to all integer types and ranges that contain the value <tt class="docutils literal"><span class="pre"><span class="DecNumber">321</span></span></tt>. That would be all builtin integer types except <tt class="docutils literal"><span class="pre"><span class="Identifier">uint8</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">int8</span></span></tt> where <tt class="docutils literal"><span class="pre"><span class="DecNumber">321</span></span></tt> would be out of range. When this literal type is assigned to a new <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> or <tt class="docutils literal"><span class="pre"><span class="Keyword">let</span></span></tt> variable, it's type will be resolved to just <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt>, not <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span> <span class="Identifier">literal</span><span class="Punctuation">(</span><span class="DecNumber">321</span><span class="Punctuation">)</span></span></tt> unlike constants. A constant keeps the full <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span> <span class="Identifier">literal</span><span class="Punctuation">(</span><span class="DecNumber">321</span><span class="Punctuation">)</span></span></tt> type. Here is an example where that difference matters.</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Identifier">int8</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;def&quot;</span>

<span class="Keyword">const</span> <span class="Identifier">tmp1</span> <span class="Operator">=</span> <span class="DecNumber">123</span>
<span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">tmp1</span><span class="Punctuation">)</span>  <span class="Comment"># OK</span>

<span class="Keyword">let</span> <span class="Identifier">tmp2</span> <span class="Operator">=</span> <span class="DecNumber">123</span>
<span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">tmp2</span><span class="Punctuation">)</span> <span class="Comment"># Error</span></pre></p>
<p>In a context with multiple overloads, the integer literal kind will always prefer the <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt> type over all other types. If none of the overloads is of type <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt>, then there will be an error because of ambiguity.</p>
<p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;abc&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Identifier">int8</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;def&quot;</span>
<span class="Identifier">foo</span><span class="Punctuation">(</span><span class="DecNumber">123</span><span class="Punctuation">)</span> <span class="Comment"># output: abc</span>

<span class="Keyword">proc</span> <span class="Identifier">bar</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Identifier">int16</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;abc&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">bar</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Identifier">int8</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;def&quot;</span>

<span class="Identifier">bar</span><span class="Punctuation">(</span><span class="DecNumber">123</span><span class="Punctuation">)</span> <span class="Comment"># Error ambiguous call</span></pre></p>
<p>In the compiler these integer literal types are represented with the node kind <tt class="docutils literal"><span class="pre"><span class="Identifier">nkIntLit</span></span></tt>, type kind <tt class="docutils literal"><span class="pre"><span class="Identifier">tyInt</span></span></tt> and the member <tt class="docutils literal"><span class="pre"><span class="Identifier">n</span></span></tt> of the type pointing back to the integer literal node in the ast containing the integer value. These are the properties that hold true for integer literal types.</p>
<pre>n.kind == nkIntLit
n.typ.kind == tyInt
n.typ.n == n</pre>
<p>Other literal types, such as <tt class="docutils literal"><span class="pre"><span class="Identifier">uint</span> <span class="Identifier">literal</span><span class="Punctuation">(</span><span class="DecNumber">123</span><span class="Punctuation">)</span></span></tt> that would automatically convert to other integer types, but prefers to become a <tt class="docutils literal"><span class="pre"><span class="Identifier">uint</span></span></tt> are not part of the Nim language.</p>
<p>In an unchecked AST, the <tt class="docutils literal"><span class="pre"><span class="Identifier">typ</span></span></tt> field is nil. The type checker will set the <tt class="docutils literal"><span class="pre"><span class="Identifier">typ</span></span></tt> field accordingly to the node kind. Nodes of kind <tt class="docutils literal"><span class="pre"><span class="Identifier">nkIntLit</span></span></tt> will get the integer literal type (e.g. <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span> <span class="Identifier">literal</span><span class="Punctuation">(</span><span class="DecNumber">123</span><span class="Punctuation">)</span></span></tt>). Nodes of kind <tt class="docutils literal"><span class="pre"><span class="Identifier">nkUIntLit</span></span></tt> will get type <tt class="docutils literal"><span class="pre"><span class="Identifier">uint</span></span></tt> (kind <tt class="docutils literal"><span class="pre"><span class="Identifier">tyUint</span></span></tt>), etc.</p>
<p>This also means that it is not possible to write a literal in an unchecked AST that will after sem checking just be of type <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt> and not implicitly convertible to other integer types. This only works for all integer types that are not <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt>. </p>
</p>
    
  </div>
</div>

      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br>
        <small style="color: var(--hint);">Made with Nim. Generated: 2024-10-23 19:00:46 UTC</small>
      </div>
    </div>
  </div>
      <script defer data-domain="nim-lang.org" src="https://plausible.io/js/plausible.js"></script>
    
</body>
</html>
